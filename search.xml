<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Vue源码解读-对参数Data的处理]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%AF%B9%E5%8F%82%E6%95%B0data%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头</p>
</blockquote>
<h3 id="将参数data整体代理到实例上，暴露在-data上"><a href="#将参数data整体代理到实例上，暴露在-data上" class="headerlink" title="将参数data整体代理到实例上，暴露在$data上"></a>将参数data整体代理到实例上，暴露在<code>$data</code>上</h3><ul>
<li>此方法出现在<code>/src/instance/internal/state.js</code>文件中，而这个文件是提供内部方法的，理论上这个方法应该放在<code>/src/instance/api/state.js</code>，暂时未明白作者为什么这么处理。</li>
<li>此方法提供用户使用新的data代替旧data的机会</li>
<li>下面部分源码解释了为什么用户可以调用$data给实例重新赋值或拿到值，以及重新给$data赋值之后Vue做了哪些事情。</li>
</ul>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$data'</span>, &#123;</div><div class="line">    get () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data</div><div class="line">    &#125;,</div><div class="line">    set (newData) &#123;</div><div class="line">        <span class="keyword">if</span> (newData !== <span class="keyword">this</span>._data) &#123;</div><div class="line">            <span class="comment">// 这并不是上面提到的疑问的答案，就算放在api中的文件里，依然可以调用到内部方法，因为此时_setData已经被挂载到prototype上了</span></div><div class="line">            <span class="keyword">this</span>._setData(newData)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 当用户调用$data给data重新赋值时的处理逻辑</span></div><div class="line">Vue.prototype._setData = <span class="function"><span class="keyword">function</span> (<span class="params">newData</span>) </span>&#123;</div><div class="line">    newData = newData || &#123;&#125;</div><div class="line">    <span class="keyword">var</span> oldData = <span class="keyword">this</span>._data</div><div class="line">    <span class="keyword">this</span>._data = newData</div><div class="line">    <span class="keyword">var</span> keys, key, i</div><div class="line">    <span class="comment">// 遍历旧的data中的所有属性，如果某些属性不存在于新的data中，将其从实例代理中删除</span></div><div class="line">    keys = <span class="built_in">Object</span>.keys(oldData)</div><div class="line">    i = keys.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        key = keys[i]</div><div class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> newData)) &#123;</div><div class="line">            <span class="keyword">this</span>._unproxy(key)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历新的data中的所有属性，将实例没有代理的属性添加到实例中</span></div><div class="line">    keys = <span class="built_in">Object</span>.keys(newData)</div><div class="line">    i = keys.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        key = keys[i]</div><div class="line">        <span class="keyword">if</span> (!hasOwn(<span class="keyword">this</span>, key)) &#123;</div><div class="line">            <span class="keyword">this</span>._proxy(key)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// __ob__用于维护数据对应的Observer实例</span></div><div class="line">    oldData.__ob__.removeVm(<span class="keyword">this</span>)</div><div class="line">    <span class="comment">// 监听新数据，具体逻辑可以查看 `Vue源码解读-数据双向绑定简化版`</span></div><div class="line">    observe(newData, <span class="keyword">this</span>)</div><div class="line">    <span class="comment">// 将所有的数据订阅者(Watchers)都推入队列中等待执行</span></div><div class="line">    <span class="keyword">this</span>._digest()</div><div class="line">&#125;</div><div class="line"><span class="comment">// data中的属性代理到实例上的处理逻辑</span></div><div class="line">Vue.prototype._proxy = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="comment">// 对$或者_开头的属性不做处理。也就是说，data中的属性名不允许以$或_开头</span></div><div class="line">    <span class="keyword">if</span> (!isReserved(key)) &#123;</div><div class="line">        <span class="comment">// 这里为什么要将this存储到self中。源码中的注释解释是：这些属性可能会在子实例中被调用</span></div><div class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">        <span class="built_in">Object</span>.defineProperty(self, key, &#123;</div><div class="line">            configurable: <span class="literal">true</span>,</div><div class="line">            enumerable: <span class="literal">true</span>,</div><div class="line">            <span class="comment">// 这里的get和set虽然只是简单的返回数据，但是在_data中对数据进行读写时，进行了逻辑处理。</span></div><div class="line">            get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> self._data[key]</div><div class="line">            &#125;,</div><div class="line">            set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">                self._data[key] = val</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 解除属性在实例上的代理</span></div><div class="line">Vue.prototype._unproxy = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!isReserved(key)) &#123;</div><div class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>[key]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将所有的数据订阅者都推入队列中等待被执行，只有通过$data改变数据时才会触发。</span></div><div class="line">Vue.prototype._digest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>._watchers.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="comment">// 传入参数true，保证复杂数据类型(Object/Array)的Watchers不会被触发</span></div><div class="line">        <span class="comment">// 暂时没理解为啥不需要复杂数据类型不需要被触发</span></div><div class="line">        <span class="keyword">this</span>._watchers[i].update(<span class="literal">true</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 工具方法，存在于`/src/util/lang.js`中，用于判断字符串是否以`$`或`_`开头</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isReserved</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> c = (str + <span class="string">''</span>).charCodeAt(<span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> c === <span class="number">0x24</span> || c === <span class="number">0x5F</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实例化过程中对data的初始化"><a href="#实例化过程中对data的初始化" class="headerlink" title="实例化过程中对data的初始化"></a>实例化过程中对data的初始化</h3><ul>
<li>Vue源码解读-参数合并中已经解释过，在对data进行初始化之前，已经对参数中的data做了处理，使其并不直接指向具体数据，而是指向一个获取数据的方法</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该方法在实例化入口中被调用</span></div><div class="line">Vue.prototype._initState = function () &#123;</div><div class="line">    <span class="comment">// this._initProps()</span></div><div class="line">    <span class="comment">// this._initMeta()</span></div><div class="line">    <span class="comment">// this._initMethods()</span></div><div class="line">    <span class="keyword">this</span>._initData() <span class="comment">// 本文只关注对数据的处理</span></div><div class="line">    <span class="comment">// this._initComputed()</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 对数据设置实例代理，并设置监听</span></div><div class="line">Vue.prototype._initData = function () &#123;</div><div class="line">    <span class="keyword">var</span> dataFn = <span class="keyword">this</span>.$options.<span class="keyword">data</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = <span class="keyword">this</span>._data = dataFn ? dataFn() : &#123;&#125;</div><div class="line">    <span class="keyword">if</span> (!isPlainObject(<span class="keyword">data</span>)) &#123;</div><div class="line">       <span class="keyword">data</span> = &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> props = <span class="keyword">this</span>._props</div><div class="line">    <span class="keyword">var</span> keys = Object.keys(<span class="keyword">data</span>)</div><div class="line">    <span class="keyword">var</span> i, key</div><div class="line">    i = keys.length</div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        <span class="comment">// 当props中没有同名属性名时，设置实例代理</span></div><div class="line">        <span class="keyword">if</span> (!props || !hasOwn(props, key)) &#123;</div><div class="line">            <span class="keyword">this</span>._proxy(key)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 设置对数据的监听(深度监听，设置set&amp;get方法)</span></div><div class="line">    <span class="comment">// 具体可查看 Vue源码解读-数据双向绑定简化版</span></div><div class="line">    observe(<span class="keyword">data</span>, <span class="keyword">this</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-$Watch的内部实现]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-watch%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br>本文主要通过$watch，分析Vue源码中对数据双向绑定的实现  </p>
</blockquote>
<h3 id="使用Demo"><a href="#使用Demo" class="headerlink" title="使用Demo"></a>使用Demo</h3><ul>
<li>下面源码的解读主要基于此demo</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    data: &#123;</div><div class="line">        <span class="string">'a'</span>: &#123;</div><div class="line">            <span class="string">'b'</span>: <span class="string">'B'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">'b'</span>: <span class="string">'B'</span>,</div><div class="line">        <span class="string">'c'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">var</span> demounwatcher = demo.$watch(<span class="string">'a.b + b + c[1] | uppercase'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(newVal, oldVal)</div><div class="line">    demounwatcher() <span class="comment">// 取消监听</span></div><div class="line">&#125;, &#123;</div><div class="line">    deep: <span class="literal">true</span>, <span class="comment">// 是否深层监听。当次属性为true，监听`a`属性，当`a.b`属性的值发生变化时也触发回调</span></div><div class="line">    immediate: <span class="literal">true</span>, <span class="comment">// 是否立即触发。当此属性为true，调用此方法时就触发一次回调</span></div><div class="line">    sync: <span class="literal">true</span>, <span class="comment">// 同步。不推入队列，直接触发执行</span></div><div class="line">    user: <span class="literal">true</span>, <span class="comment">// 推入用户队列还是指令队列</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><ul>
<li>监听表达式，在表达式发生变化时触发回调</li>
<li>主要逻辑封装在Watcher类中</li>
<li>指令和表达式的区别：指令包含表达式。如：<code>a + b | uppercase</code>是指令，<code>a + b</code>是表达式。表大会可以直接在js中执行，而指令需要处理后才能执行</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> <span class="params">(expOrFn, cb, options)</span> &#123;</span></div><div class="line">    var <span class="keyword">vm</span> = this</div><div class="line">    var parsed</div><div class="line">    <span class="keyword">if</span> (typeof expOrFn === <span class="string">'string'</span>) &#123;</div><div class="line">        // 解析指令，拆分表达式和过滤器</div><div class="line">        parsed = parseDirective(expOrFn)</div><div class="line">        expOrFn = parsed.expression</div><div class="line">    &#125;</div><div class="line">    var watcher = <span class="keyword">new</span> Watcher(<span class="keyword">vm</span>, expOrFn, <span class="keyword">cb</span>, &#123;</div><div class="line">        deep: <span class="keyword">options</span> &amp;&amp; <span class="keyword">options</span>.deep,</div><div class="line">        <span class="keyword">sync</span>: <span class="keyword">options</span> &amp;&amp; <span class="keyword">options</span>.<span class="keyword">sync</span>,</div><div class="line">        <span class="built_in">filter</span><span class="variable">s:</span> parsed &amp;&amp; parsed.filters,</div><div class="line">        user: !options || <span class="keyword">options</span>.user !== false</div><div class="line">    &#125;)</div><div class="line">    // 如果设置了立即触发，则在调用$watch时就触发一次回调</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">options</span> &amp;&amp; <span class="keyword">options</span>.immediate) &#123;</div><div class="line">        <span class="keyword">cb</span>.<span class="keyword">call</span>(<span class="keyword">vm</span>, watcher.value)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> <span class="params">()</span> &#123;</span></div><div class="line">        watcher.teardown()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Watcher类"><a href="#Watcher类" class="headerlink" title="Watcher类"></a>Watcher类</h4><ul>
<li>构造函数</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数解释</span></div><div class="line"><span class="comment">// vm Vue实例</span></div><div class="line"><span class="comment">// expOrFn 表达式或函数</span></div><div class="line"><span class="comment">// cb 指令值或函数值发生变化时的回调</span></div><div class="line"><span class="comment">// options 配置参数，用于控制Watcher的行为</span></div><div class="line"><span class="comment">//      - &#123;Array&#125; filters // 过滤器</span></div><div class="line"><span class="comment">//      - &#123;Boolean&#125; twoWay // 是否为双向监听</span></div><div class="line"><span class="comment">//      - &#123;Boolean&#125; deep // 是否为深度监听</span></div><div class="line"><span class="comment">//      - &#123;Boolean&#125; user // 是否用户，用于判断放入哪一个队列(有两条异步队列)</span></div><div class="line"><span class="comment">//      - &#123;Boolean&#125; sync // 是否为同步执行回调</span></div><div class="line"><span class="comment">//      - &#123;Boolean&#125; lazy // true 下次触发时获取expOrFn当前值；false 立即获取当前值</span></div><div class="line"><span class="comment">//      - &#123;Function&#125; [preProcess] // 应用过滤器之前执行的方法</span></div><div class="line"><span class="comment">//      - &#123;Function&#125; [postProcess] // 应用过滤器之后执行的方法</span></div><div class="line">export <span class="keyword">default</span> function Watcher (vm, expOrFn, cb, options) &#123;</div><div class="line">    <span class="comment">// 将配置扩展到当前类上</span></div><div class="line">    <span class="keyword">if</span> (options) &#123;</div><div class="line">        extend(<span class="keyword">this</span>, options)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 是否是订阅的函数</span></div><div class="line">    <span class="keyword">var</span> isFn = typeof expOrFn === <span class="string">'function'</span></div><div class="line">    <span class="keyword">this</span>.vm = vm</div><div class="line">    <span class="comment">// 将当前Watcher类推送到对应的Vue实例中</span></div><div class="line">    vm._watchers.push(<span class="keyword">this</span>)</div><div class="line">    <span class="keyword">this</span>.expression = expOrFn</div><div class="line">    <span class="keyword">this</span>.cb = cb</div><div class="line">    <span class="comment">// 在订阅者管理员(batcher.js)中用到</span></div><div class="line">    <span class="keyword">this</span>.id = ++uid </div><div class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></div><div class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy</div><div class="line">    <span class="keyword">this</span>.deps = [] <span class="comment">// 当前订阅者被哪些管理员管理着</span></div><div class="line">    <span class="keyword">this</span>.newDeps = []</div><div class="line">    <span class="keyword">this</span>.depIds = new Set() <span class="comment">// 订阅者管理员的id</span></div><div class="line">    <span class="keyword">this</span>.newDepIds = new Set()</div><div class="line">    <span class="keyword">this</span>.prevError = <span class="literal">null</span></div><div class="line">    <span class="keyword">if</span> (isFn) &#123;</div><div class="line">        <span class="comment">// 如果函数，相当于指定了当前订阅者获取数据的方法，每次订阅者通过这个方法获取数据然后与之前的值进行对比</span></div><div class="line">        <span class="keyword">this</span>.getter = expOrFn</div><div class="line">        <span class="keyword">this</span>.setter = undefined</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则的话解析表达式，具体可以看$get &amp; $set的内部实现中对parseExpression的解释</span></div><div class="line">        <span class="keyword">var</span> res = parseExpression(expOrFn, <span class="keyword">this</span>.twoWay)</div><div class="line">        <span class="keyword">this</span>.getter = res.<span class="keyword">get</span></div><div class="line">        <span class="keyword">this</span>.setter = res.<span class="keyword">set</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// value维护的是数据的旧值，拿到当前值，当下一次订阅的数据发生变化时和新值进行对比</span></div><div class="line">    <span class="comment">// 如果是lazy模式，则先不拿数据</span></div><div class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</div><div class="line">        ? undefined</div><div class="line">        : <span class="keyword">this</span>.<span class="keyword">get</span>()</div><div class="line">    <span class="keyword">this</span>.queued = <span class="keyword">this</span>.shallow = <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取expOrFn的值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Watcher.prototype.<span class="keyword">get</span> = function () &#123;</div><div class="line">    <span class="comment">// 看下面对beforeGet的解释</span></div><div class="line">    <span class="keyword">this</span>.beforeGet()</div><div class="line">    <span class="keyword">var</span> scope = <span class="keyword">this</span>.scope || <span class="keyword">this</span>.vm</div><div class="line">    <span class="keyword">var</span> value</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 调用getter时，会将此订阅者实例推送的到订阅者管理员的仓库中</span></div><div class="line">        value = <span class="keyword">this</span>.getter.call(scope, scope)</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line">    <span class="comment">// 如果需要深度监听</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</div><div class="line">        <span class="comment">// 请看下面对traverse的解释</span></div><div class="line">        traverse(value)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 前置执行逻辑</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.preProcess) &#123;</div><div class="line">        value = <span class="keyword">this</span>.preProcess(value)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 应用过滤器</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filters) &#123;</div><div class="line">        value = scope._applyFilters(value, <span class="literal">null</span>, <span class="keyword">this</span>.filters, <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 后置执行逻辑</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.postProcess) &#123;</div><div class="line">        value = <span class="keyword">this</span>.postProcess(value)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// </span></div><div class="line">    <span class="keyword">this</span>.afterGet()</div><div class="line">    <span class="keyword">return</span> value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在获取expOrFn的值之前，先将Dep类的静态属性target设置成当前订阅者。目的是在读取expOrFn(触发get)的值时，如果发现Dep.target有值，可以将当前订阅者推入到订阅者管理员的仓库中(beforeGet)</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">Watcher</span>.proto<span class="keyword">type</span>.beforeGet = function () &#123;</div><div class="line">    <span class="type">Dep</span>.target = this</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果需要深度订阅时，对expOrFn的值进行递归处理。在数据读取的瞬间，就完成了想要完成的逻辑。</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">const seenObjects = <span class="keyword">new</span> Set()</div><div class="line"><span class="comment">// 内部递归时会传入seen参数，用于保存seen中已经存在的数据</span></div><div class="line"><span class="keyword">function</span> traverse (<span class="keyword">val</span>, seen) &#123;</div><div class="line">    <span class="keyword">let</span> i, keys</div><div class="line">    <span class="keyword">if</span> (!seen) &#123;</div><div class="line">        <span class="comment">// 如果没有配饰seen，把它指向seenObjects，并清空内容</span></div><div class="line">        seen = seenObjects</div><div class="line">        seen.clear()</div><div class="line">    &#125;</div><div class="line">    const isA = isArray(<span class="keyword">val</span>)</div><div class="line">    const isO = isObject(<span class="keyword">val</span>)</div><div class="line">    <span class="keyword">if</span> (isA || isO) &#123;</div><div class="line">        <span class="comment">// 如果当前值有Observer</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">val</span>.__ob__) &#123;</div><div class="line">            <span class="comment">// 拿到当前值的Observer的订阅者管理员的id</span></div><div class="line">            var depId = <span class="keyword">val</span>.__ob__.dep.id</div><div class="line">            <span class="comment">// 如果seen中已经有这个id了，直接返回</span></div><div class="line">            <span class="keyword">if</span> (seen.has(depId)) &#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 否则添加到seen中</span></div><div class="line">                seen.add(depId)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 递归数组</span></div><div class="line">        <span class="keyword">if</span> (isA) &#123;</div><div class="line">            i = <span class="keyword">val</span>.length</div><div class="line">            <span class="comment">// 触发数组内部元素的get，因为此时Dep.target依然引用了当前Watcher，因此数组内部元素的Observer的订阅者管理员中也会被加入当前订阅者从而达到深度监听的目的</span></div><div class="line">            <span class="keyword">while</span> (i--) traverse(<span class="keyword">val</span>[i], seen)</div><div class="line">        <span class="comment">// 递归对象</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isO) &#123;</div><div class="line">            keys = Object.keys(<span class="keyword">val</span>)</div><div class="line">            i = keys.length</div><div class="line">            <span class="keyword">while</span> (i--) traverse(<span class="keyword">val</span>[keys[i]], seen)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行get后期的一些善后工作(afterGet)</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">Watcher</span>.proto<span class="keyword">type</span>.afterGet = function () &#123;</div><div class="line">    // 每次在<span class="type">Watcher</span>调用get方法之后都必须将<span class="type">Dep</span>的target属性设置为null，避免影响别人读取数据时的逻辑执行</div><div class="line">    <span class="type">Dep</span>.target = null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-指令V-Text的编译过程]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%8C%87%E4%BB%A4v-text%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br>本文以一个v-text的用例为demo，讲解Vue内部的处理过程<br>文中重点解释v-text的编译过程。对data的处理过程将被简化<br>如果对data处理部分不够清楚的。请看<code>$watch的内部实现</code>或者<code>数据双向绑定简化版</code>   </p>
</blockquote>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ul>
<li>template</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"demo"</span>&gt;</div><div class="line">    &lt;p v-<span class="built_in">text</span>=<span class="string">"msg"</span>&gt;&lt;/p&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure>
<ul>
<li>Vue实例</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var demo = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#demo'</span>,</div><div class="line">    dat<span class="variable">a:</span> &#123;</div><div class="line">        ms<span class="variable">g:</span> <span class="string">'Hello Vue!'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Vue实例对data的处理"><a href="#Vue实例对data的处理" class="headerlink" title="Vue实例对data的处理"></a>Vue实例对data的处理</h3><ul>
<li>在之前的文章中已经对data的处理进行了很多次的解释(其实就是设置setter&amp;getter，同时创建一个订阅者管理员的过程)。</li>
<li>看看message被处理成啥样了哈。只给一个样例，就不多做解释了。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">&#123;</div><div class="line">    msg: <span class="string">'Hello Vue!'</span>,</div><div class="line">    <span class="function"><span class="keyword">get</span> <span class="title">msg</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(Dep.target)&#123;</div><div class="line">            dep.add(Dep.target)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> msg</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">set</span> <span class="title">msg</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        dep.notify()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="模板的编译过程"><a href="#模板的编译过程" class="headerlink" title="模板的编译过程"></a>模板的编译过程</h3><ul>
<li>编译元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileElement</span> (<span class="params">el, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hasAttrs = el.hasAttributes()</div><div class="line">    <span class="keyword">var</span> attrs = hasAttrs &amp;&amp; toArray(el.attributes)</div><div class="line">    <span class="keyword">var</span> linkFn = compileDirectives(attrs, options)</div><div class="line">    <span class="keyword">return</span> linkFn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>编译指令。这里解释了各种指令的匹配过程，可以只看<code>v-text</code>匹配到的部分</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配修改器，如：`.async`</span></div><div class="line"><span class="keyword">const</span> modifierRE = <span class="regexp">/\.[^\.]+/g</span></div><div class="line"><span class="comment">// 匹配transition指令。</span></div><div class="line"><span class="comment">// 动态绑定：`v-bind:transition=""`或`:transition=""`</span></div><div class="line"><span class="comment">// 静态绑定：`transition`</span></div><div class="line"><span class="keyword">const</span> transitionRE = <span class="regexp">/^(v-bind:|:)?transition$/</span></div><div class="line"><span class="comment">// 匹配动态绑定 `v-bind:`或`:`</span></div><div class="line"><span class="keyword">const</span> bindRE = <span class="regexp">/^v-bind:|^:/</span></div><div class="line"><span class="comment">// 匹配普通指令`v-text` `v-ref:xxx` 或`v-el:xxx`</span></div><div class="line"><span class="keyword">const</span> dirAttrRE = <span class="regexp">/^v-([^:]+)(?:$|:(.*)$)/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileDirectives</span> (<span class="params">attrs, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = attrs.length</div><div class="line">    <span class="keyword">var</span> dirs = [] <span class="comment">// 存储当前元素上的所有属性解析之后的值</span></div><div class="line">    <span class="keyword">var</span> attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched</div><div class="line">    <span class="comment">// 遍历元素上的属性</span></div><div class="line">    <span class="keyword">while</span> (i--) &#123;</div><div class="line">        attr = attrs[i]</div><div class="line">        name = rawName = attr.name</div><div class="line">        value = rawValue = attr.value</div><div class="line">        <span class="comment">// 解析属性的值，看是否有`&#123;&#123;xxx&#125;&#125;`或者`&#123;&#123;&#123;xxx&#125;&#125;&#125;`</span></div><div class="line">        tokens = parseText(value)</div><div class="line">        <span class="comment">// 重置arg</span></div><div class="line">        arg = <span class="literal">null</span></div><div class="line">        <span class="comment">// 解析修改器</span></div><div class="line">        modifiers = parseModifiers(name)</div><div class="line">        <span class="comment">// 删除修改器</span></div><div class="line">        name = name.replace(modifierRE, <span class="string">''</span>)</div><div class="line">        <span class="comment">// 处理`&#123;&#123;&#125;&#125;`类型的值</span></div><div class="line">        <span class="keyword">if</span> (tokens) &#123;</div><div class="line">            value = tokensToExp(tokens)</div><div class="line">            arg = name</div><div class="line">            pushDir(<span class="string">'bind'</span>, publicDirectives.bind, tokens)</div><div class="line">        <span class="comment">// 处理过渡类型的指令</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transitionRE.test(name)) &#123;</div><div class="line">            modifiers.literal = !bindRE.test(name)</div><div class="line">            pushDir(<span class="string">'transition'</span>, internalDirectives.transition)</div><div class="line">        <span class="comment">// 处理`on`类型的指令</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onRE.test(name)) &#123;</div><div class="line">            arg = name.replace(onRE, <span class="string">''</span>)</div><div class="line">            pushDir(<span class="string">'on'</span>, publicDirectives.on)</div><div class="line">        <span class="comment">// 处理bind类型的指令</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bindRE.test(name)) &#123;</div><div class="line">            dirName = name.replace(bindRE, <span class="string">''</span>)</div><div class="line">            <span class="keyword">if</span> (dirName === <span class="string">'style'</span> || dirName === <span class="string">'class'</span>) &#123;</div><div class="line">                pushDir(dirName, internalDirectives[dirName])</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                arg = dirName</div><div class="line">                pushDir(<span class="string">'bind'</span>, publicDirectives.bind)</div><div class="line">            &#125;</div><div class="line">        <span class="comment">// 处理其他类型的指令。v-text指令将在这里被匹配</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((matched = name.match(dirAttrRE))) &#123;</div><div class="line">            <span class="comment">// 指令名</span></div><div class="line">            dirName = matched[<span class="number">1</span>]</div><div class="line">            <span class="comment">// 指令值</span></div><div class="line">            arg = matched[<span class="number">2</span>]</div><div class="line">            <span class="comment">// 匹配到对应的指令处理逻辑，指令处理逻辑中包含</span></div><div class="line">            <span class="comment">/* &#123;</span></div><div class="line">                bind()&#123;&#125;,</div><div class="line">                updata()&#123;&#125;</div><div class="line">            &#125; */</div><div class="line">            dirDef = resolveAsset(options, <span class="string">'directives'</span>, dirName, <span class="literal">true</span>)</div><div class="line">            <span class="keyword">if</span> (dirDef) &#123;</div><div class="line">                pushDir(dirName, dirDef)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pushDir</span> (<span class="params">dirName, def, interpTokens</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> parsed = parseDirective(value)</div><div class="line">        dirs.push(&#123;</div><div class="line">            name: dirName, <span class="comment">// 指令名称 `text`</span></div><div class="line">            attr: rawName, <span class="comment">// 指令原始名 `v-text`</span></div><div class="line">            raw: rawValue, <span class="comment">// 指令原始值 `msg`</span></div><div class="line">            def: def, <span class="comment">// 指令定义&#123;bind(), update()&#125;</span></div><div class="line">            arg: arg, <span class="comment">// 参数。`v-ref:xxx`中的`xxx`部分</span></div><div class="line">            modifiers: modifiers, <span class="comment">// 修改器</span></div><div class="line">            expression: parsed &amp;&amp; parsed.expression, <span class="comment">// 指令原始值中的表达式部分</span></div><div class="line">            filters: parsed &amp;&amp; parsed.filters, <span class="comment">// 指令原始值中的过滤器部分</span></div><div class="line">            interp: interpTokens,</div><div class="line">            hasOneTime: hasOneTimeToken</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 返回一个方法，用于指令和Vue实例的绑定</span></div><div class="line">    <span class="keyword">if</span> (dirs.length) &#123;</div><div class="line">        <span class="keyword">return</span> makeNodeLinkFn(dirs)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>指令和DOM的绑定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNodeLinkFn</span> (<span class="params">directives</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">nodeLinkFn</span> (<span class="params">vm, el, host, scope, frag</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> i = directives.length</div><div class="line">        <span class="keyword">while</span> (i--) &#123;</div><div class="line">            vm._bindDir(directives[i], el, host, scope, frag)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 绑定的过程其实就是将指令实例化并存储到Vue实例的_directives数组中的过程</span></div><div class="line">Vue.prototype._bindDir = <span class="function"><span class="keyword">function</span> (<span class="params">descriptor, node, host, scope, frag</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._directives.push(</div><div class="line">        <span class="comment">// 实例化指令</span></div><div class="line">        <span class="keyword">new</span> Directive(descriptor, <span class="keyword">this</span>, node, host, scope, frag)</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-$Get & $Set的内部实现]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-get-set%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br>$get &amp; $set是Vue对外暴露给用户使用的，用于对data的内容进行获取和设置的api。<br>出现在instance/api/data.js中，但调用的方法并不一定都在该文件中。<br>本文主要按方法的执行流程分析源码。  </p>
</blockquote>
<h3 id="get"><a href="#get" class="headerlink" title="$get"></a>$get</h3><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul>
<li>使用demo</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> demo = new Vue(&#123;</div><div class="line">    data: &#123;</div><div class="line">        <span class="selector-tag">a</span>: <span class="number">1</span>,</div><div class="line">        <span class="selector-tag">b</span>: <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">demo.<span class="variable">$get</span>(<span class="string">'a + b'</span>)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><ul>
<li>将字符串表达式处理成一个对象，并调用对象的get方法返回结果。解构如下：</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="built_in">exp</span>: <span class="built_in">exp</span> <span class="comment">// 字符串表达式</span></div><div class="line">    get: <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span>&#125; <span class="comment">// 针对该表达式的get方法，用于返回该表达式的值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>源代码</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一个参数：待处理的字符串表达式</div><div class="line">// 第二个参数：对外api文档中并未提到第二个参数，暂时先不考虑</div><div class="line">Vue.prototype.$<span class="built_in">get</span> = <span class="function"><span class="keyword">function</span> <span class="params">(exp, asStatement)</span> &#123;</span></div><div class="line">    // 解析表达式，并返回一个包含<span class="built_in">get</span>方法的对象。</div><div class="line">    var <span class="keyword">res</span> = parseExpression(<span class="built_in">exp</span>)</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">res</span>) &#123;</div><div class="line">        // 这里不能保证在执行<span class="built_in">get</span>时不报错，因此需要放入<span class="keyword">try</span>/<span class="keyword">catch</span>中</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            // <span class="built_in">get</span>方法接收一个参数作为它的参数</div><div class="line">            <span class="keyword">return</span> <span class="keyword">res</span>.<span class="built_in">get</span>.<span class="keyword">call</span>(this, this)</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">e</span>) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理字符串表达式-parseExpression"><a href="#处理字符串表达式-parseExpression" class="headerlink" title="处理字符串表达式(parseExpression)"></a>处理字符串表达式(parseExpression)</h4><ul>
<li>首先检查该字符串表达式是否存在于缓存中。如果存在，直接取出。否则开始解析，将结果返回，并存放于缓存中</li>
<li>此方法不进为$get &amp; $set提供服务，因此以下的处理流程可能并不仅限于处理$get &amp; $set时</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// <span class="built_in">exp</span> 表达式</div><div class="line">// needSet 是否需要<span class="keyword">set</span>对表达式进行赋值。使用$<span class="built_in">get</span>获取表达式的值时，此值为false。因此这部分逻辑被剔除</div><div class="line">export <span class="function"><span class="keyword">function</span> <span class="title">parseExpression</span> <span class="params">(exp, needSet)</span> &#123;</span></div><div class="line">    // 去掉前后空字符</div><div class="line">    <span class="built_in">exp</span> = <span class="built_in">exp</span>.trim()</div><div class="line">    // 尝试从缓存获取。因为表达式可能会被不止一次的用到。缓存类部分容我稍后再禀。可暂时理解为它维护了一个存放键值对的<span class="keyword">map</span>表</div><div class="line">    var hit = expressionCache.<span class="built_in">get</span>(<span class="built_in">exp</span>)</div><div class="line">    <span class="keyword">if</span> (hit) &#123;</div><div class="line">        <span class="keyword">return</span> hit</div><div class="line">    &#125;</div><div class="line">    // 存放解析之后的结果</div><div class="line">    var <span class="keyword">res</span> = &#123; <span class="built_in">exp</span>: <span class="built_in">exp</span> &#125;</div><div class="line">    // 每个<span class="built_in">exp</span>表达式的解析结果中必须有<span class="built_in">get</span>方法</div><div class="line">    <span class="keyword">res</span>.<span class="built_in">get</span> = isSimplePath(<span class="built_in">exp</span>) &amp;&amp; <span class="built_in">exp</span>.indexOf(<span class="string">'['</span>) &lt; <span class="number">0</span></div><div class="line">        // 如果是简单表达式，并且表达式中不包含中括号</div><div class="line">        // 简单不需要处理，直接返回表达式的执行方法即可</div><div class="line">        // 简单的表达式直接返回等待执行即可，不需要走下面复杂的处理逻辑，提升性能</div><div class="line">        ? makeGetterFn(<span class="string">'scope.'</span> + <span class="built_in">exp</span>)</div><div class="line">        // 否则对<span class="built_in">exp</span>进行处理并最终返回在当前实例下的一个执行常规表达式的方法</div><div class="line">        : compileGetter(<span class="built_in">exp</span>)</div><div class="line">    expressionCache.<span class="keyword">put</span>(<span class="built_in">exp</span>, <span class="keyword">res</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">res</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="判断是否为简单路径-isSimplePath"><a href="#判断是否为简单路径-isSimplePath" class="headerlink" title="判断是否为简单路径(isSimplePath)"></a>判断是否为简单路径(isSimplePath)</h4><p>大部分路径都是简单路径，如：a.b、a[‘b’]、a[‘’]。<br>少部分路径比较复杂，如：a.b + a.c + 1。<br>复杂路径的处理逻辑虽然也能处理简单路径，但流程会比较复杂。为了性能考虑，才有了这个判断。  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 以下是对正则的解释：</div><div class="line">// 以大小写字母或者_$开头</div><div class="line">// 中间是常规字符(字母数字下划线)</div><div class="line">// 以 .加上任意个大小写字母或者<span class="emphasis">_$ 或者 ['加上尽可能少的任一个字符加上'] 或者 ["加上尽可能少的任一个字符加上"] 或者 [加上任一个数字加] 或者 [加上以大小写字母或者_</span>$开头以任意个字母数字_$结尾] 的任意序列结尾</div><div class="line">// 如：<span class="code">`obj.a["b"]['c'][1]`</span></div><div class="line">const pathTestRE = /^[<span class="string">A-Za-z_$</span>][<span class="symbol">\w$</span>]<span class="emphasis">*(?:\.[A-Za-z_$][\w$]*</span>|\[<span class="string">'.*?'\</span>]|\[<span class="string">".*?"\</span>]|\[<span class="string">\d+\</span>]|\[<span class="string">[A-Za-z_$</span>][<span class="symbol">\w$</span>]<span class="emphasis">*\])*</span>$/</div><div class="line"></div><div class="line">// 如：<span class="code">`true`</span> <span class="code">`false`</span> <span class="code">`'true'`</span> <span class="code">`'false'`</span></div><div class="line">const booleanLiteralRE = /^(?:true|false)$/</div><div class="line"></div><div class="line">export function isSimplePath (exp) &#123;</div><div class="line"><span class="code">    return pathTestRE.test(exp) &amp;&amp;</span></div><div class="line"><span class="code">        // 不将true/false作为简单表达式路径</span></div><div class="line"><span class="code">        !booleanLiteralRE.test(exp) &amp;&amp;</span></div><div class="line"><span class="code">        排除`Math.`开头的字符串</span></div><div class="line"><span class="code">        exp.slice(0, 5) !== 'Math.'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="给表达式返回对应的get方法-makeGetterFn"><a href="#给表达式返回对应的get方法-makeGetterFn" class="headerlink" title="给表达式返回对应的get方法(makeGetterFn)"></a>给表达式返回对应的get方法(makeGetterFn)</h4><p>简单表达式时，直接返回该方法的执行结果<br>复杂表达式时，对表达式进行各种处理(继续看可以看到做了哪些处理)之后，仍然会返回该方法的执行结果  </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// scope: 当前方法的执行环境。但部分时候为当前Vue实例，for循环时猜测为当前循环所对应的数据对象(猜测，尚未看for指令的实现)</span></div><div class="line"><span class="comment">// body，如：scope.a.b(简单表达式)、scope.a + scope.b(复杂表达式)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeGetterFn</span> <span class="params">(body)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// scope是函数的参数；body是方法体。将此方法赋值给表达式的get方法，就可以方便的拿到表达式的值</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'scope'</span>, <span class="string">'return '</span> + body + <span class="string">';'</span>)</span></span></div><div class="line">    &#125; <span class="title">catch</span> <span class="params">(e)</span> &#123;</div><div class="line">        <span class="keyword">return</span> noop</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对复杂表达式进行编译，获得get方法-compileGetter"><a href="#对复杂表达式进行编译，获得get方法-compileGetter" class="headerlink" title="对复杂表达式进行编译，获得get方法(compileGetter)"></a>对复杂表达式进行编译，获得get方法(compileGetter)</h4><ul>
<li>此方法可能会处理的情况有：$get、指令解析等</li>
<li>它主要的功能是对表达式进行拆分之后，在需要执行环境的变量前面加上执行环境<code>scope</code></li>
<li>当然表达式中还存在部分不需要添加执行环境的变量，所以在添加之前，先将这部分放到save的数组中</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> improperKeywords =</div><div class="line">    '<span class="keyword">break</span>,case,<span class="keyword">class</span>,catch,<span class="keyword">const</span>,<span class="keyword">continue</span>,debugger,default,' +</div><div class="line">    'delete,<span class="keyword">do</span>,<span class="keyword">else</span>,export,extends,finally,<span class="keyword">for</span>,function,<span class="keyword">if</span>,' +</div><div class="line">    'import,<span class="keyword">in</span>,instanceof,let,<span class="keyword">return</span>,super,switch,throw,try,' +</div><div class="line">    '<span class="keyword">var</span>,<span class="keyword">while</span>,with,yield,enum,await,implements,package,' +</div><div class="line">    'protected,static,interface,private,public'</div><div class="line"></div><div class="line"><span class="comment">// 匹配上述任意关键字</span></div><div class="line"><span class="keyword">const</span> improperKeywordsRE =</div><div class="line">    new RegExp('^(' + improperKeywords.<span class="keyword">replace</span>(/,/<span class="keyword">g</span>, '\\b|') + '\\b)')</div><div class="line"></div><div class="line"><span class="comment">// &#123;或, 加任意字母 加 至少一个任意大小写字符数字或$_加任意空格加: 或者 '加不是'和\或者任意个非元字符加' 或者 "加不是"和\或者任意个非元字符加" 或者 `加不是`和\或者任意个非元字符加$&#123; 或者 &#125;加不是`\或者任意个非元字符加` 或者 `加不是`和\或者任意个非元字符  或者 new 或者 typeof 或者 void</span></div><div class="line"><span class="comment">// 如`&#123;id :` `'abc'&#125;`  `typeof `  </span></div><div class="line"><span class="keyword">const</span> saveRE = /[\&#123;,]\s*[\w\<span class="variable">$_</span>]+\s*:|('(?:[^'\\]|\\.)*'|<span class="string">"(?:[^"</span>\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\&#123;|\&#125;(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |<span class="keyword">typeof</span> |void /<span class="keyword">g</span></div><div class="line"></div><div class="line"><span class="comment">// 任意空白字符</span></div><div class="line"><span class="keyword">const</span> wsRE = /\s/<span class="keyword">g</span></div><div class="line"></div><div class="line"><span class="comment">// 不能以大小写字母数字_$.开头，后面跟大小写字母_$，后面再跟任意大小写字母数字_$</span></div><div class="line"><span class="comment">// 此表达式可以将一个表达式中的不同变量进行拆解。想想上一行解释和js中字面量命名规范的关系</span></div><div class="line"><span class="keyword">const</span> identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/<span class="keyword">g</span></div><div class="line"></div><div class="line"><span class="comment">// 匹配一个被双引号引起来的数字</span></div><div class="line"><span class="keyword">const</span> restoreRE = /<span class="string">"(\d+)"</span>/<span class="keyword">g</span></div><div class="line"></div><div class="line">let saved = []</div><div class="line"></div><div class="line">function compileGetter (exp) &#123;</div><div class="line">    <span class="comment">// 不允许在表达式中使用js保留字</span></div><div class="line">    <span class="keyword">if</span> (improperKeywordsRE.<span class="keyword">test</span>(exp)) &#123;</div><div class="line">        process.env.NODE_ENV !== 'production' &amp;&amp; warn(</div><div class="line">            'Avoid using reserved keywords <span class="keyword">in</span> expression: ' + <span class="built_in">exp</span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 一个新的表达式编译开始时，重置saved数组为空</span></div><div class="line">    saved.length = 0</div><div class="line">    <span class="keyword">var</span> body = <span class="built_in">exp</span></div><div class="line">        <span class="comment">// 将匹配到的字符传给save方法，并将匹配到的部分替换为save方法的返回值，最后去除空格</span></div><div class="line">        <span class="comment">// 避免这部分变量被添加执行环境</span></div><div class="line">        .<span class="keyword">replace</span>(saveRE, <span class="keyword">save</span>)</div><div class="line">        <span class="comment">// 删除字符串中的所有空格</span></div><div class="line">        .<span class="keyword">replace</span>(wsRE, '')</div><div class="line">    <span class="comment">// 在表达式之前加上一个空格，方便被identRE匹配为一个独立的字面量</span></div><div class="line">    body = (' ' + body)</div><div class="line">        <span class="comment">// 将匹配到的字面量(开头是个非字面量部分的字符)进行处理并回填，如` callHandler` `(item`，做了哪些处理，请看对rewrite的解释</span></div><div class="line">        .<span class="keyword">replace</span>(identRE, rewrite)</div><div class="line">        <span class="comment">// 将不需要添加执行环境的变量替换回来</span></div><div class="line">        .<span class="keyword">replace</span>(restoreRE, <span class="keyword">restore</span>)</div><div class="line">    <span class="keyword">return</span> makeGetterFn(body)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="给表达式中的字面量加上执行环境限制-rewrite"><a href="#给表达式中的字面量加上执行环境限制-rewrite" class="headerlink" title="给表达式中的字面量加上执行环境限制(rewrite)"></a>给表达式中的字面量加上执行环境限制(rewrite)</h4><ul>
<li>只有加上了执行环境，表达式才能正常，顺利的执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不需要被加上执行环境的字面量</span></div><div class="line"><span class="keyword">const</span> allowedKeywords =</div><div class="line">  <span class="string">'Math,Date,this,true,false,null,undefined,Infinity,NaN,'</span> +</div><div class="line">  <span class="string">'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,'</span> +</div><div class="line">  <span class="string">'encodeURIComponent,parseInt,parseFloat'</span></div><div class="line"></div><div class="line"><span class="comment">// 匹配是以上述字面量中的一个开头，有独立边界的字符串</span></div><div class="line"><span class="keyword">const</span> allowedKeywordsRE =</div><div class="line">  <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^('</span> + allowedKeywords.replace(<span class="regexp">/,/g</span>, <span class="string">'\\b|'</span>) + <span class="string">'\\b)'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 匹配一个被双引号引起来的数字</span></div><div class="line"><span class="keyword">const</span> restoreRE = <span class="regexp">/"(\d+)"/g</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">rewrite</span> (<span class="params">raw</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> c = raw.charAt(<span class="number">0</span>)</div><div class="line">    <span class="comment">// 去掉开头部分被额外添加的那个空格</span></div><div class="line">    <span class="keyword">var</span> path = raw.slice(<span class="number">1</span>)</div><div class="line">    <span class="comment">// 如果是js原始方法或对象，如Math.cell()等，直接返回即可。不需要加上`scope`,因为他们都是全局的</span></div><div class="line">    <span class="keyword">if</span> (allowedKeywordsRE.test(path)) &#123;</div><div class="line">        <span class="keyword">return</span> raw</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 如果被匹配到的字符串中(这个字符串是由一个或多个非变量字符串和变量组成的)</span></div><div class="line">        <span class="comment">// 如果字符串中存在双引号，先将字符串中匹配到`"123"`形式的字符串替换为原始字符串</span></div><div class="line">        path = path.indexOf(<span class="string">'"'</span>) &gt; <span class="number">-1</span></div><div class="line">            ? path.replace(restoreRE, restore)</div><div class="line">            : path</div><div class="line">        <span class="keyword">return</span> c + <span class="string">'scope.'</span> + path</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="存储不需要加执行环境的变量"><a href="#存储不需要加执行环境的变量" class="headerlink" title="存储不需要加执行环境的变量"></a>存储不需要加执行环境的变量</h4><ul>
<li>先存起来，等需要添加执行环境的变量都加上之后，再替换回来</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配`\n`</span></div><div class="line"><span class="keyword">const</span> newlineRE = <span class="regexp">/\n/g</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> saved = []</div><div class="line"></div><div class="line"><span class="comment">// 将上面匹配到的字符串进行一点处理之后存入saved数组，并返回这个字符串在数组中的位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">save</span> (<span class="params">str, isString</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = saved.length</div><div class="line">    saved[i] = isString</div><div class="line">        ? str.replace(newlineRE, <span class="string">'\\n'</span>)</div><div class="line">        : str</div><div class="line">    <span class="comment">// 需要用`"`等不能构成变量的元素将`i`包裹起来，因为正常变量中也是可能包含数字的</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'"'</span> + i + <span class="string">'"'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h3><h4 id="什么场景下会用到它呢？"><a href="#什么场景下会用到它呢？" class="headerlink" title="什么场景下会用到它呢？"></a>什么场景下会用到它呢？</h4><ul>
<li>修改数组的某一项时</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> demo = new Vue(&#123;</div><div class="line">    data: &#123;</div><div class="line">        <span class="selector-tag">a</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">demo<span class="selector-class">.a</span>[<span class="number">1</span>] = <span class="string">'1'</span> <span class="comment">// 由于在设置a属性的set方法时，判断a的值是否发生变化是通过内存中的存储位置来进行的，因此直接操作数组的某一项时，不会触发a属性的订阅者的执行</span></div><div class="line">demo.<span class="variable">$set</span>(<span class="string">'a[1]'</span>, <span class="string">'1'</span>) <span class="comment">// 这样就没问题啦</span></div></pre></td></tr></table></figure>
<ul>
<li>设置不存在的属性时</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> demo = new Vue(&#123;</div><div class="line">    data: &#123;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">demo<span class="selector-class">.a</span><span class="selector-class">.b</span> = <span class="number">2</span> <span class="comment">// 此时连a都没有，肯定不能直接这么赋值</span></div><div class="line">demo.<span class="variable">$set</span>(<span class="string">'a.b'</span>, <span class="number">2</span>) <span class="comment">// 这样就没问题啦</span></div></pre></td></tr></table></figure>
<h4 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h4><ul>
<li>将字符串表达式处理成一个对象，并调用对象的set方法进行赋值。解构如下：</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    exp: exp <span class="comment">// 字符串表达式</span></div><div class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 针对该表达式的get方法，用于返回该表达式的值</span></div><div class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(val)</span></span>&#123;&#125; <span class="comment">// 针对该表达式的get方法，用于给表达式赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>源代码</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$<span class="keyword">set</span> = <span class="function"><span class="keyword">function</span> <span class="params">(exp, val)</span> &#123;</span></div><div class="line">    // 和$<span class="built_in">get</span>中不同的是，需要传入第二个参数true，接下来就看parseExpression的了</div><div class="line">    var <span class="keyword">res</span> = parseExpression(<span class="built_in">exp</span>, true)</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">res</span> &amp;&amp; <span class="keyword">res</span>.<span class="keyword">set</span>) &#123;</div><div class="line">        // 看来解析之后的结果中出了上面出现的<span class="built_in">get</span>，又多了一个<span class="keyword">set</span>方法</div><div class="line">        <span class="keyword">res</span>.<span class="keyword">set</span>.<span class="keyword">call</span>(this, this, val)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理字符串表达式-parseExpression-1"><a href="#处理字符串表达式-parseExpression-1" class="headerlink" title="处理字符串表达式(parseExpression)"></a>处理字符串表达式(parseExpression)</h4><ul>
<li>同$get中调用的是同一个方法，只不过将这个方法拆成了两部分</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 为了精简逻辑，这里将源码中的缓存逻辑和<span class="built_in">get</span>方法的处理删除了</div><div class="line">export <span class="function"><span class="keyword">function</span> <span class="title">parseExpression</span> <span class="params">(exp, needSet)</span> &#123;</span></div><div class="line">    <span class="built_in">exp</span> = <span class="built_in">exp</span>.trim()</div><div class="line">    var <span class="keyword">res</span> = &#123; <span class="built_in">exp</span>: <span class="built_in">exp</span> &#125;</div><div class="line">    <span class="keyword">if</span> (needSet) &#123;</div><div class="line">        // 发现主要处理逻辑又封装了一个方法，讨厌！</div><div class="line">        <span class="keyword">res</span>.<span class="keyword">set</span> = compileSetter(<span class="built_in">exp</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">res</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="编译字符串，得到字符串的set方法-compileSetter"><a href="#编译字符串，得到字符串的set方法-compileSetter" class="headerlink" title="编译字符串，得到字符串的set方法(compileSetter)"></a>编译字符串，得到字符串的set方法(compileSetter)</h4><ul>
<li>源代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileSetter</span> (<span class="params">exp</span>) </span>&#123;</div><div class="line">    <span class="comment">// 先解析exp，需要用到parsers中封装的功能了</span></div><div class="line">    <span class="keyword">var</span> path = parsePath(exp)</div><div class="line">    <span class="keyword">if</span> (path) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">scope, val</span>) </span>&#123;</div><div class="line">            setPath(scope, path, val)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="再看看路径解析吧"><a href="#再看看路径解析吧" class="headerlink" title="再看看路径解析吧"></a>再看看路径解析吧</h4><ul>
<li>先从缓存取，如果缓存里没有，那就自己动手解析吧</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们发现暴露在外面的这部分接口主要处理缓存问题，嘎嘎。</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hit = pathCache.get(path)</div><div class="line">    <span class="keyword">if</span> (!hit) &#123;</div><div class="line">        hit = parse(path)</div><div class="line">        <span class="keyword">if</span> (hit) &#123;</div><div class="line">            pathCache.put(path, hit)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hit</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解析路径，将路径解析成由字面量组成的数组-parsePath"><a href="#解析路径，将路径解析成由字面量组成的数组-parsePath" class="headerlink" title="解析路径，将路径解析成由字面量组成的数组(parsePath)"></a>解析路径，将路径解析成由字面量组成的数组(parsePath)</h4><ul>
<li>得到一个由路径拆解成的字面量的数组，同时数组中维护着原始路径，如：<code>a[&quot;b&quot;][&#39;c&#39;].d</code>最终会被解析成</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> res = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line">res<span class="selector-class">.raw</span> = <span class="selector-tag">a</span>[<span class="string">"b"</span>][<span class="string">'c'</span>]<span class="selector-class">.d</span> <span class="comment">// 字符串</span></div></pre></td></tr></table></figure>
<ul>
<li>源码，这部分不看也罢，比较复杂。只需要知道它干了什么就好。但如果感兴趣，可以继续往下看。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解析路径如：a / a.b / a['b'].c / a["b"].c</span></div><div class="line"><span class="comment">// 行为</span></div><div class="line"><span class="keyword">var</span> APPEND = <span class="number">0</span> <span class="comment">// 字符串拼接</span></div><div class="line"><span class="keyword">var</span> PUSH = <span class="number">1</span> <span class="comment">// 当一个变量或属性被解析完整之后就会被推入数组</span></div><div class="line"><span class="keyword">var</span> INC_SUB_PATH_DEPTH = <span class="number">2</span> <span class="comment">// </span></div><div class="line"><span class="keyword">var</span> PUSH_SUB_PATH = <span class="number">3</span></div><div class="line"></div><div class="line"><span class="comment">// 当前解析所处的状态</span></div><div class="line"><span class="keyword">var</span> BEFORE_PATH = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> IN_PATH = <span class="number">1</span></div><div class="line"><span class="keyword">var</span> BEFORE_IDENT = <span class="number">2</span></div><div class="line"><span class="keyword">var</span> IN_IDENT = <span class="number">3</span></div><div class="line"><span class="keyword">var</span> IN_SUB_PATH = <span class="number">4</span></div><div class="line"><span class="keyword">var</span> IN_SINGLE_QUOTE = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> IN_DOUBLE_QUOTE = <span class="number">6</span></div><div class="line"><span class="keyword">var</span> AFTER_PATH = <span class="number">7</span></div><div class="line"><span class="keyword">var</span> ERROR = <span class="number">8</span></div><div class="line"><span class="comment">// 当状态为BEFORE_PATH时，解析到下一个字符时状态及需要执行的动作</span></div><div class="line">pathStateMachine[BEFORE_PATH] = &#123;</div><div class="line">    <span class="string">'ws'</span>: [BEFORE_PATH], <span class="comment">// 解析到的下一个字符如果是空格则状态仍为BEFORE_PATH</span></div><div class="line">    <span class="string">'ident'</span>: [IN_IDENT, APPEND], <span class="comment">// 解析到的下一个字符如果是[_$a-zA-Z]，状态改为IN_IDENT，并执行APPEND动作</span></div><div class="line">    <span class="string">'['</span>: [IN_SUB_PATH], <span class="comment">// 解析到下一个字符时如果是[，则将状态改为IN_SUB_PATH，没有动作</span></div><div class="line">    <span class="string">'eof'</span>: [AFTER_PATH] <span class="comment">// 解析到下一个字符发现已经结束了，则状态改为AFTER_PATH</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 当状态为IN_PATH时，解析到下一个字符时状态及需要执行的动作</span></div><div class="line">pathStateMachine[IN_PATH] = &#123;</div><div class="line">    <span class="string">'ws'</span>: [IN_PATH], <span class="comment">// 仍然是IN_PATH状态，无动作</span></div><div class="line">    <span class="string">'.'</span>: [BEFORE_IDENT], <span class="comment">// BEFORE_IDENT状态，无动作</span></div><div class="line">    <span class="string">'['</span>: [IN_SUB_PATH], <span class="comment">// IN_SUB_PATH状态，无动作</span></div><div class="line">    <span class="string">'eof'</span>: [AFTER_PATH] <span class="comment">// AFTER_PATH状态，无动作</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 上一个字符是'.'时，下一个状态会变成BEFORE_IDENT</span></div><div class="line">pathStateMachine[BEFORE_IDENT] = &#123;</div><div class="line">    <span class="string">'ws'</span>: [BEFORE_IDENT],</div><div class="line">    <span class="string">'ident'</span>: [IN_IDENT, APPEND]</div><div class="line">&#125;</div><div class="line"></div><div class="line">pathStateMachine[IN_IDENT] = &#123;</div><div class="line">    <span class="string">'ident'</span>: [IN_IDENT, APPEND],</div><div class="line">    <span class="string">'0'</span>: [IN_IDENT, APPEND],</div><div class="line">    <span class="string">'number'</span>: [IN_IDENT, APPEND],</div><div class="line">    <span class="string">'ws'</span>: [IN_PATH, PUSH],</div><div class="line">    <span class="string">'.'</span>: [BEFORE_IDENT, PUSH],</div><div class="line">    <span class="string">'['</span>: [IN_SUB_PATH, PUSH],</div><div class="line">    <span class="string">'eof'</span>: [AFTER_PATH, PUSH]</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在子路径中遇到单引号和双引号时，将单引号和双引号也一起放入字符串中，后面会再进行处理</span></div><div class="line">pathStateMachine[IN_SUB_PATH] = &#123;</div><div class="line">    <span class="string">"'"</span>: [IN_SINGLE_QUOTE, APPEND],</div><div class="line">    <span class="string">'"'</span>: [IN_DOUBLE_QUOTE, APPEND],</div><div class="line">    <span class="string">'['</span>: [IN_SUB_PATH, INC_SUB_PATH_DEPTH],</div><div class="line">    <span class="string">']'</span>: [IN_PATH, PUSH_SUB_PATH],</div><div class="line">    <span class="string">'eof'</span>: ERROR,</div><div class="line">    <span class="string">'else'</span>: [IN_SUB_PATH, APPEND]</div><div class="line">&#125;</div><div class="line"><span class="comment">// 当遇到单引号是，状态变为IN_SINGLE_QUOTE，除非遇到下一个单引号，或者报错，否则一直处于IN_SINGLE_QUOTE状态，并执行APPEND动作</span></div><div class="line">pathStateMachine[IN_SINGLE_QUOTE] = &#123;</div><div class="line">    <span class="string">"'"</span>: [IN_SUB_PATH, APPEND],</div><div class="line">    <span class="string">'eof'</span>: ERROR,</div><div class="line">    <span class="string">'else'</span>: [IN_SINGLE_QUOTE, APPEND]</div><div class="line">&#125;</div><div class="line"><span class="comment">// 同单引号</span></div><div class="line">pathStateMachine[IN_DOUBLE_QUOTE] = &#123;</div><div class="line">    <span class="string">'"'</span>: [IN_SUB_PATH, APPEND],</div><div class="line">    <span class="string">'eof'</span>: ERROR,</div><div class="line">    <span class="string">'else'</span>: [IN_DOUBLE_QUOTE, APPEND]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> keys = [] <span class="comment">// 记录解析之后的路径的数组，如：a['b'].c，会解析成[a, b, c]</span></div><div class="line">    <span class="keyword">var</span> index = <span class="number">-1</span> <span class="comment">// 记录当前解析到的字符的index</span></div><div class="line">    <span class="keyword">var</span> mode = BEFORE_PATH <span class="comment">// 记录当前解析所处的状态，默认处于解析开始状态</span></div><div class="line">    <span class="keyword">var</span> subPathDepth = <span class="number">0</span> <span class="comment">// </span></div><div class="line">    <span class="keyword">var</span> c, newChar, key, type, transition, action, typeMap</div><div class="line">    <span class="keyword">var</span> actions = [] <span class="comment">// 行为数组，不同状态时，会调用不同的行为</span></div><div class="line">    <span class="comment">// 将解析好的一个字符串放入数组</span></div><div class="line">    actions[PUSH] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</div><div class="line">            keys.push(key)</div><div class="line">            key = <span class="literal">undefined</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将正在被解析的字符串连接到已解析的字符串的后面</span></div><div class="line">    actions[APPEND] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key === <span class="literal">undefined</span>) &#123;</div><div class="line">            key = newChar</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            key += newChar</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    actions[INC_SUB_PATH_DEPTH] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        actions[APPEND]()</div><div class="line">        subPathDepth++</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 路径中包含字符串时，先去除字符串再推入数组中</span></div><div class="line">    actions[PUSH_SUB_PATH] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (subPathDepth &gt; <span class="number">0</span>) &#123;</div><div class="line">            subPathDepth--</div><div class="line">            mode = IN_SUB_PATH</div><div class="line">            actions[APPEND]()</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            subPathDepth = <span class="number">0</span></div><div class="line">            key = formatSubPath(key)</div><div class="line">            <span class="keyword">if</span> (key === <span class="literal">false</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                actions[PUSH]()</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">maybeUnescapeQuote</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> nextChar = path[index + <span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> ((mode === IN_SINGLE_QUOTE &amp;&amp; nextChar === <span class="string">"'"</span>) ||</div><div class="line">            (mode === IN_DOUBLE_QUOTE &amp;&amp; nextChar === <span class="string">'"'</span>)) &#123;</div><div class="line">            index++</div><div class="line">            newChar = <span class="string">'\\'</span> + nextChar</div><div class="line">            actions[APPEND]()</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (mode != <span class="literal">null</span>) &#123;</div><div class="line">        index++ <span class="comment">// 记录当前字符的index</span></div><div class="line">        c = path[index] <span class="comment">// 拿到当前字符</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c === <span class="string">'\\'</span> &amp;&amp; maybeUnescapeQuote()) &#123;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 拿到当前字符的类型</span></div><div class="line">        type = getPathCharType(c)</div><div class="line">        <span class="comment">// 根据上一个状态，拿到当前可能出现的类型的全部处理逻辑和状态</span></div><div class="line">        typeMap = pathStateMachine[mode]</div><div class="line">        <span class="comment">// 匹配到当前类型的处理逻辑和状态</span></div><div class="line">        transition = typeMap[type] || typeMap[<span class="string">'else'</span>] || ERROR</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (transition === ERROR) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="comment">// parse error</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将状态改为当前的状态</span></div><div class="line">        mode = transition[<span class="number">0</span>]</div><div class="line">        action = actions[transition[<span class="number">1</span>]]</div><div class="line">        <span class="keyword">if</span> (action) &#123;</div><div class="line">            <span class="comment">// 状态机中没有任何一个状态维护了数组的第三数据，因此目前来看没啥卵用</span></div><div class="line">            newChar = transition[<span class="number">2</span>]</div><div class="line">            <span class="comment">// 这里拿到的一定是当前被解析的这个字符串</span></div><div class="line">            newChar = newChar === <span class="literal">undefined</span></div><div class="line">                ? c</div><div class="line">                : newChar</div><div class="line">            <span class="comment">// 执行动作</span></div><div class="line">            <span class="keyword">if</span> (action() === <span class="literal">false</span>) &#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果是最后一步，也就是所有字符都解析完之后的一次循环</span></div><div class="line">        <span class="keyword">if</span> (mode === AFTER_PATH) &#123;</div><div class="line">            keys.raw = path</div><div class="line">            <span class="keyword">return</span> keys</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最后再看set方法的调用-入口中被调用-，逻辑封装在setPath中"><a href="#最后再看set方法的调用-入口中被调用-，逻辑封装在setPath中" class="headerlink" title="最后再看set方法的调用(入口中被调用)，逻辑封装在setPath中"></a>最后再看set方法的调用(入口中被调用)，逻辑封装在setPath中</h4><ul>
<li>源码</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">export function setPath (obj, path, val) &#123;</div><div class="line">    var original = obj</div><div class="line">    <span class="comment">// 如果传进来的path是字符串，先去解析path</span></div><div class="line">    <span class="keyword">if</span> (typeof path === <span class="string">'string'</span>) &#123;</div><div class="line">        path = parse(path)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!path || !isObject(obj)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">    &#125;</div><div class="line">    var last, <span class="built_in">key</span></div><div class="line">    <span class="keyword">for</span> (var i = <span class="number">0</span>, l = path.length; i &lt; l; i++) &#123;</div><div class="line">        last = obj <span class="comment">// 记录上一次遍历处理之后的值</span></div><div class="line">        <span class="built_in">key</span> = path[i]</div><div class="line">        <span class="comment">// 这部分逻辑，抱歉暂时还不知道执行场景</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>.charAt(<span class="number">0</span>) === <span class="string">'*'</span>) &#123;</div><div class="line">            <span class="built_in">key</span> = parseExpression(<span class="built_in">key</span>.slice(<span class="number">1</span>)).<span class="built_in">get</span>.call(original, original)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果当前处理的不是数组的最后一项</span></div><div class="line">        <span class="keyword">if</span> (i &lt; l - <span class="number">1</span>) &#123;</div><div class="line">            obj = obj[<span class="built_in">key</span>]</div><div class="line">            <span class="comment">// 如果不是对象时，也就是说目前尚没有这个属性，或者属性不是对象类型</span></div><div class="line">            <span class="keyword">if</span> (!isObject(obj)) &#123;</div><div class="line">                obj = &#123;&#125;</div><div class="line">                <span class="comment">// 在上一次遍历处理的结果上进行属性扩展，同时在这个方法中会进行数据监听</span></div><div class="line">                <span class="built_in">set</span>(last, <span class="built_in">key</span>, obj)</div><div class="line">            &#125;</div><div class="line">        <span class="comment">// 处理到最后一项时</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 如果上一次遍历的结果是数组</span></div><div class="line">            <span class="keyword">if</span> (isArray(obj)) &#123;</div><div class="line">                <span class="comment">// 调用数组的$set方法(Vue从Array的原型链上扩展了此方法)</span></div><div class="line">                obj.$<span class="built_in">set</span>(<span class="built_in">key</span>, val)</div><div class="line">            <span class="comment">// 如果上一次遍历的结果是对象，并且属性存在该对象中</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">key</span> in obj) &#123;</div><div class="line">                <span class="comment">// 直接赋值就行啦</span></div><div class="line">                obj[<span class="built_in">key</span>] = val</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 否则就是调用set了，当然也是为了添加对此属性的监控</span></div><div class="line">                <span class="built_in">set</span>(obj, <span class="built_in">key</span>, val)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="对数组进行赋值时-数组的-set方法"><a href="#对数组进行赋值时-数组的-set方法" class="headerlink" title="对数组进行赋值时(数组的$set方法)"></a>对数组进行赋值时(数组的$set方法)</h4><ul>
<li>源码</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def( <span class="comment">// Object.defineProperty的简写</span></div><div class="line">    arrayProto, <span class="comment">// Array.prototype</span></div><div class="line">    <span class="string">'$set'</span>,</div><div class="line">    function $<span class="keyword">set</span> (index, <span class="keyword">val</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= <span class="keyword">this</span>.length) &#123;</div><div class="line">            <span class="keyword">this</span>.length = Number(index) + <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 这一句是关键，splice会改变原始数组，从而触发数组的Watchers逻辑执行</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.splice(index, <span class="number">1</span>, <span class="keyword">val</span>)[<span class="number">0</span>]</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="对尚不存在的属性进行赋值时-set"><a href="#对尚不存在的属性进行赋值时-set" class="headerlink" title="对尚不存在的属性进行赋值时(set)"></a>对尚不存在的属性进行赋值时(set)</h4><ul>
<li>如此啰嗦的处理，主要是为了给新属性添加监控，方便订阅者可以订阅该属性</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">export function <span class="keyword">set</span> (obj, key, <span class="keyword">val</span>) &#123;</div><div class="line">    <span class="comment">// 如果obj已经包含key属性了，说明属性监控什么的都已经处理好了，直接改变值就行了</span></div><div class="line">    <span class="keyword">if</span> (hasOwn(obj, key)) &#123;</div><div class="line">        obj[key] = <span class="keyword">val</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果obj是Vue实例，那实际上操作的数据是保存在_data中的，对它执行set</span></div><div class="line">    <span class="keyword">if</span> (obj._isVue) &#123;</div><div class="line">        <span class="keyword">set</span>(obj._data, key, <span class="keyword">val</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> ob = obj.__ob__</div><div class="line">    <span class="comment">// 如果当前obj没有有__ob__属性，说明这个对象不需要被监听，也是直接赋值就行了</span></div><div class="line">    <span class="keyword">if</span> (!ob) &#123;</div><div class="line">        obj[key] = <span class="keyword">val</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对obj添加key属性，同时给key属性设置getter&amp;setter</span></div><div class="line">    ob.convert(key, <span class="keyword">val</span>)</div><div class="line">    <span class="comment">// 触发obj上添加的监控，因为此时obj已经发生变化了</span></div><div class="line">    ob.dep.notify()</div><div class="line">    <span class="comment">// 如果Observer监听的是最外层数据($data引用的数据)，它会维护它所监听的数据所在的Vue实例的引用</span></div><div class="line">    <span class="keyword">if</span> (ob.vms) &#123;</div><div class="line">        <span class="keyword">var</span> i = ob.vms.length</div><div class="line">        <span class="keyword">while</span> (i--) &#123;</div><div class="line">            <span class="keyword">var</span> vm = ob.vms[i]</div><div class="line">            <span class="comment">// 在实例上进行数据代理</span></div><div class="line">            vm._proxy(key)</div><div class="line">            <span class="comment">// 在当前实例下触发所有的监听</span></div><div class="line">            vm._digest()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">val</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="接下来的处理逻辑请看数据双线绑定简化版和Watchers-数据订阅者-异步执行队列"><a href="#接下来的处理逻辑请看数据双线绑定简化版和Watchers-数据订阅者-异步执行队列" class="headerlink" title="接下来的处理逻辑请看数据双线绑定简化版和Watchers(数据订阅者)异步执行队列"></a>接下来的处理逻辑请看<code>数据双线绑定简化版</code>和<code>Watchers(数据订阅者)异步执行队列</code></h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-参数合并(mergeOptions)]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%8F%82%E6%95%B0%E5%90%88%E5%B9%B6-mergeOptions/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br>该功能主要用于类的继承过程中和类的实例化过程中。主要是按照预先设定好的合并策略将父类和子类或者类和实例中的参数进行合并<br><code>/src/util/options.js</code>  </p>
</blockquote>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><ul>
<li>对外暴露的参数合并入口，主要在Vue实例化和Vue子类声明(组件声明)及实例化前期处理参数时被调用。</li>
</ul>
<a id="more"></a>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果存在vm，则说明是在实例化过程中被调用</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params">parent, child, vm</span>) </span>&#123;</div><div class="line">    <span class="comment">// 处理局部组件，保证局部组件已经初始化(继承了Vue，成为Vue的子类)</span></div><div class="line">    guardComponents(child)</div><div class="line">    <span class="comment">// 处理props参数的值，保证props的值按照key-&gt;value的方式被赋值</span></div><div class="line">    guardProps(child)</div><div class="line">    <span class="built_in">var</span> options = &#123;&#125;</div><div class="line">    <span class="built_in">var</span> key</div><div class="line">    <span class="comment">// 这部分代码只存在于源码中，产出之后的代码中并不存在，但官方文档中却提供了用法说明，比较奇怪</span></div><div class="line">    <span class="comment">// 先不管它</span></div><div class="line">    <span class="keyword">if</span> (child.extends) &#123;</div><div class="line">        <span class="built_in">parent</span> = <span class="keyword">typeof</span> child.extends === <span class="string">'function'</span></div><div class="line">            ? mergeOptions(<span class="built_in">parent</span>, child.extends.options, vm)</div><div class="line">            : mergeOptions(<span class="built_in">parent</span>, child.extends, vm)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// mixins提供可复用功能，当不同组件之间共用一部分初始化参数时使用</span></div><div class="line">    <span class="comment">// 引用一个数组</span></div><div class="line">    <span class="keyword">if</span> (child.mixins) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</div><div class="line">            <span class="built_in">var</span> mixin = child.mixins[i]</div><div class="line">            <span class="built_in">var</span> mixinOptions = mixin.prototype <span class="keyword">instanceof</span> Vue</div><div class="line">                ? <span class="attribute">mixin.options</span></div><div class="line">                : mixin</div><div class="line">            <span class="comment">// 先将mixins中的数据同parent进行合并</span></div><div class="line">            <span class="built_in">parent</span> = mergeOptions(<span class="built_in">parent</span>, mixinOptions, vm)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="built_in">parent</span>) &#123;</div><div class="line">        mergeField(key)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</div><div class="line">        <span class="keyword">if</span> (!hasOwn(<span class="built_in">parent</span>, key)) &#123;</div><div class="line">            mergeField(key)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">        <span class="built_in">var</span> strat = strats[key] || defaultStrat</div><div class="line">        <span class="comment">// 调用对应的合并策略</span></div><div class="line">        options[key] = strat(<span class="built_in">parent</span>[key], child[key], vm, key)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> options</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 主要用于确保局部组件被正确的初始化</span></div><div class="line"><span class="comment">// 对外暴露的局部组件的使用方式有如下两种</span></div><div class="line"><span class="comment">// let Haha = Vue.extend(options)</span></div><div class="line"><span class="comment">// components: &#123;</span></div><div class="line"><span class="comment">//     'haha': Haha, // 第一种，事先声明</span></div><div class="line"><span class="comment">//     'hengheng': options // 第二种，只传入初始化的参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardComponents</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (options.components) &#123;</div><div class="line">        <span class="comment">// guardArrayAssets其实在这里啥也没干，忽略它就好</span></div><div class="line">        <span class="built_in">var</span> components = options.components =</div><div class="line">            guardArrayAssets(options.components)</div><div class="line">        <span class="built_in">var</span> ids = <span class="built_in">Object</span>.keys(components)</div><div class="line">        <span class="built_in">var</span> def</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>, l = ids.length; i &lt; l; i++) &#123;</div><div class="line">            <span class="built_in">var</span> key = ids[i]</div><div class="line">            <span class="comment">// 避免用户使用通用的html标签和Vue预定的(slot|partial|component)标签</span></div><div class="line">            <span class="comment">// 也就是说，如果用户用了上述key，会直接被忽略，不生效</span></div><div class="line">            <span class="keyword">if</span> (commonTagRE.test(key) || reservedTagRE.test(key)) &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            def = components[key]</div><div class="line">            <span class="comment">// 此处存在重复劳动，第一种使用方式获得的值已经是Vue的子类了，但依然会在调用isPlainObject时返回true，进入Vue.extend进行处理。虽然不会出问题，但相当于丢弃了之前的子类初始化，重新进行了一次。</span></div><div class="line">            <span class="comment">// 所以在使用中，如果想要避免此类情况，可以全都使用第二种方式进行局部组件的声明</span></div><div class="line">            <span class="keyword">if</span> (isPlainObject(def)) &#123;</div><div class="line">                components[key] = Vue.extend(def)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// prop参数传入的方式有如下几种</span></div><div class="line"><span class="comment">// props: ['a', 'b'] // 第一种：简单语法，不做数据校验</span></div><div class="line"><span class="comment">// props: &#123; // 第二种：对象语法，指定验证要求</span></div><div class="line"><span class="comment">//     'a': &#123;&#125;,</span></div><div class="line"><span class="comment">//     'b': &#123;&#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardProps</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="built_in">var</span> props = options.props</div><div class="line">    <span class="built_in">var</span> i, val</div><div class="line">    <span class="comment">// 如果是第一种用法</span></div><div class="line">    <span class="keyword">if</span> (isArray(props)) &#123;</div><div class="line">        <span class="comment">// 转换成第二种用法</span></div><div class="line">        options.props = &#123;&#125;</div><div class="line">        i = props.length</div><div class="line">        <span class="keyword">while</span> (i--) &#123;</div><div class="line">            val = props[i]</div><div class="line">            <span class="comment">// 如果数组元素是字符串，则字符串为props的key，没有类型检查配置</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</div><div class="line">                options.props[val] = <span class="literal">null</span></div><div class="line">            <span class="comment">// 数组元素可以是对象，可以进行类型检查配置，但这种用法解构不清晰，因此没有出现在Vue的官方文档里</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val.name) &#123;</div><div class="line">                options.props[val.name] = val</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">// 如果是第二种用法</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPlainObject(props)) &#123;</div><div class="line">        <span class="built_in">var</span> keys = <span class="built_in">Object</span>.keys(props)</div><div class="line">        i = keys.length</div><div class="line">        <span class="keyword">while</span> (i--) &#123;</div><div class="line">            val = props[keys[i]]</div><div class="line">            <span class="comment">// 如果某个prop被赋值为function，将其转化为对象，把function作为对象的type属性的值，该function用于校验当前的prop的合法性</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'function'</span>) &#123;</div><div class="line">                props[keys[i]] = &#123; <span class="attribute">type</span>: val &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="strats"><a href="#strats" class="headerlink" title="strats"></a>strats</h4><ul>
<li>绑定处理参数中各种数据的方法，统一在入口方法mergeOptions()中被调用</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建strats对象并绑定到config上</span></div><div class="line"><span class="selector-tag">var</span> strats = config<span class="selector-class">.optionMergeStrategies</span> = Object.create(null)</div></pre></td></tr></table></figure>
<ul>
<li><p>声明对参数中data的处理策略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parentVal 继承过程中代表父类的data，实例化过程中代表类中的data</span></div><div class="line"><span class="comment">// childVal 继承过程中代表子类的data，实例化过程中代表实例化过程中参数中传入的data</span></div><div class="line"><span class="comment">// vm 当前实例。如果不存在vm参数，则说明是通过component声明的组件的声明过程，此时组件尚未实例化，因此不存在对实例的引用</span></div><div class="line">strats.data = <span class="function"><span class="keyword">function</span> (<span class="params">parentVal, childVal, vm</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!vm) &#123;</div><div class="line">        <span class="comment">// 对组件声明过程中data的处理逻辑</span></div><div class="line">        <span class="comment">// 此时parentVal和childVal，只要有数据，必须是function类型，因为这里处理的组件的声明过程，Vue要求组件(子类)的声明时传入的data必须是function类型，否则不进行处理。原因是：组件是可复用功能模块，如果直接传入object类型(想想引用类型的特征)的data，会导致组件的所以实例都引用向同一份数据。但是个人觉得，Vue应该在内部去处理，避免用户踩进这样的坑。而不是提醒用户使用的时候小心有这样的坑。</span></div><div class="line">        </div><div class="line">        <span class="comment">// 如果当前组件没有data，则返回父类的data。</span></div><div class="line">        <span class="comment">// 父类可以保证data只能是undefined或者function类型（Vue类的data是undefined，其它Vue的子类或者子类的子类都在当前方法中被要求只能父类的类型相同）</span></div><div class="line">        <span class="keyword">if</span> (!childVal) &#123;</div><div class="line">            <span class="keyword">return</span> parentVal</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果当前组件的data不是function类型，则返回父类的data</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> childVal !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">return</span> parentVal</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 此时已经保证了子类的存在并且为function类型，所有如果父类不存在，直接返回子类就好了</span></div><div class="line">        <span class="keyword">if</span> (!parentVal) &#123;</div><div class="line">            <span class="keyword">return</span> childVal</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 如果上面的情况都不存在，说明父类和子类都存在data，且都是function类型</span></div><div class="line">        <span class="comment">// 此处只能返回一个方法，用于拿到合并后的数据。</span></div><div class="line">        <span class="comment">// 为啥要返回一个处理数据的方法，而不是直接返回处理之后的结果呢？</span></div><div class="line">        <span class="comment">// 因为data()中可能存在和当前实例绑定的数据，因此必须在实例化过程中才能拿到实例相关的数据</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedDataFn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> mergeData(</div><div class="line">                childVal.call(<span class="keyword">this</span>),</div><div class="line">                parentVal.call(<span class="keyword">this</span>)</div><div class="line">            )</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentVal || childVal) &#123;</div><div class="line">        <span class="comment">// 处理实例化过程中的data</span></div><div class="line">        <span class="comment">// 为啥还是返回一个处理函数呢？</span></div><div class="line">        <span class="comment">// 因为数据是在实时变化的，因此需要在使用的时候实时进行合并。</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedInstanceDataFn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// instance merge</span></div><div class="line">            <span class="keyword">var</span> instanceData = <span class="keyword">typeof</span> childVal === <span class="string">'function'</span></div><div class="line">                ? childVal.call(vm)</div><div class="line">                : childVal</div><div class="line">            <span class="keyword">var</span> defaultData = <span class="keyword">typeof</span> parentVal === <span class="string">'function'</span></div><div class="line">                ? parentVal.call(vm)</div><div class="line">                : <span class="literal">undefined</span></div><div class="line">            <span class="keyword">if</span> (instanceData) &#123;</div><div class="line">                <span class="keyword">return</span> mergeData(instanceData, defaultData)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> defaultData</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeData</span> (<span class="params">to, from</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> key, toVal, fromVal</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</div><div class="line">        toVal = to[key]</div><div class="line">        fromVal = <span class="keyword">from</span>[key]</div><div class="line">        <span class="keyword">if</span> (!hasOwn(to, key)) &#123;</div><div class="line">            set(to, key, fromVal)</div><div class="line">        <span class="comment">// 如果被merge的属性在to中是对象，在from中也是对象，则深度merge。</span></div><div class="line">        <span class="comment">// 如果仅to中是对象，from是非object类型，则保留to中的数据不变。</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(toVal) &amp;&amp; isObject(fromVal)) &#123;</div><div class="line">            mergeData(toVal, fromVal)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> to</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>声明对参数中el的处理策略，此时拿到的可能是一个选择器字符串或者DOM对象</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">strats.<span class="keyword">el</span> = <span class="function"><span class="keyword">function</span> <span class="params">(parentVal, childVal, vm)</span> &#123;</span></div><div class="line">    <span class="keyword">if</span> (!vm &amp;&amp; childVal &amp;&amp; typeof childVal !== <span class="string">'function'</span>) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    var <span class="keyword">ret</span> = childVal || parentVal</div><div class="line">    // 在组件声明时，如果传入了<span class="keyword">el</span>参数，此时<span class="keyword">el</span>必须是<span class="function"><span class="keyword">function</span>类型。同<span class="title">data</span>一样，是为了避免此组件的所有实例指向同一个元素</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">vm</span> &amp;&amp; typeof <span class="keyword">ret</span> === <span class="string">'function'</span></div><div class="line">        ? <span class="keyword">ret</span>.<span class="keyword">call</span>(<span class="keyword">vm</span>)</div><div class="line">        : <span class="keyword">ret</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>声明对参数中声明周期钩子中绑定的处理函数的处理策略，不同阶段的钩子处理策略是相同的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">strats.init =</div><div class="line">strats.created =</div><div class="line">strats.ready =</div><div class="line">strats.attached =</div><div class="line">strats.detached =</div><div class="line">strats.beforeCompile =</div><div class="line">strats.compiled =</div><div class="line">strats.beforeDestroy =</div><div class="line">strats.destroyed =</div><div class="line">strats.activate = <span class="function"><span class="keyword">function</span> (<span class="params">parentVal, childVal</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果存在当前实例当前生命周期的钩子</span></div><div class="line">    <span class="keyword">return</span> childVal</div><div class="line">        <span class="comment">// 如果当前实例的父级实例中存在当前生命周期的钩子</span></div><div class="line">        ? parentVal</div><div class="line">            <span class="comment">// 则将当前实例当前生命周期的钩子添加到父级钩子数组的后面(父级当前声明周期钩子只要存在，一定已经被处理成数组了)</span></div><div class="line">            ? parentVal.concat(childVal)</div><div class="line">            <span class="comment">// 如果父级当前生命周期钩子不存在，且当前实例的当前生命周期钩子是数组</span></div><div class="line">            : isArray(childVal)</div><div class="line">                <span class="comment">// 则返回当前实例的当前生命周期钩子数组</span></div><div class="line">                ? childVal</div><div class="line">                <span class="comment">// 如果父级当前生命周期钩子不存在，且当前实例的当前生命周期钩子不是数组，则将其放入数组</span></div><div class="line">                : [childVal]</div><div class="line">        <span class="comment">// 如果不存在当前实例当前生命周期的钩子，则直接返回父级当前生命周期钩子(undefined或数组)</span></div><div class="line">        : parentVal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>声明对参数中events &amp; watch的处理策略</li>
</ul>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">strats.watch =</div><div class="line">strats.events = <span class="function"><span class="keyword">function</span> (<span class="params">parentVal, childVal</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!childVal) <span class="keyword">return</span> parentVal</div><div class="line">    <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</div><div class="line">    <span class="built_in">var</span> ret = &#123;&#125;</div><div class="line">    <span class="comment">// 现将父级对应参数扩展到ret上</span></div><div class="line">    extend(ret, parentVal)</div><div class="line">    <span class="comment">// 然后遍历子级(当前)参数</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> key <span class="keyword">in</span> childVal) &#123;</div><div class="line">        <span class="built_in">var</span> <span class="built_in">parent</span> = ret[key]</div><div class="line">        <span class="built_in">var</span> child = childVal[key]</div><div class="line">        <span class="comment">// 将父级和子级中都存在值的属性指向一个数组，并将父级中的值放入数组，方便讲子级中的同名属性值放入数组</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">parent</span> &amp;&amp; !isArray(<span class="built_in">parent</span>)) &#123;</div><div class="line">            <span class="built_in">parent</span> = [<span class="built_in">parent</span>]</div><div class="line">        &#125;</div><div class="line">        ret[key] = <span class="built_in">parent</span></div><div class="line">            ? <span class="built_in">parent</span>.concat(child)</div><div class="line">            : [child]</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 此处并未保证返回的ret的所以属性都指向数组</span></div><div class="line">    <span class="keyword">return</span> ret</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>声明对参数中props &amp; methods &amp; computed的处理策略</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">strats.props =</div><div class="line">strats.methods =</div><div class="line">strats.computed = <span class="function"><span class="keyword">function</span> <span class="params">(parentVal, childVal)</span> &#123;</span></div><div class="line">    <span class="keyword">if</span> (!childVal) <span class="keyword">return</span> parentVal</div><div class="line">    <span class="keyword">if</span> (!parentVal) <span class="keyword">return</span> childVal</div><div class="line">    var <span class="keyword">ret</span> = Object.create(null) // 与var <span class="keyword">ret</span> = &#123;&#125;相同</div><div class="line">    <span class="built_in">extend</span>(<span class="keyword">ret</span>, parentVal)</div><div class="line">    // 合并策略：子覆盖父</div><div class="line">    <span class="built_in">extend</span>(<span class="keyword">ret</span>, childVal)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">ret</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>声明对参数components/directive/elementDirective/filter/transition/partial的处理策略。</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    <span class="symbol">'component</span>',</div><div class="line">    <span class="symbol">'directive</span>',</div><div class="line">    <span class="symbol">'elementDirective</span>',</div><div class="line">    <span class="symbol">'filter</span>',</div><div class="line">    <span class="symbol">'transition</span>',</div><div class="line">    <span class="symbol">'partial</span>'</div><div class="line">].forEach(<span class="name">function</span> (<span class="name">type</span>) &#123;</div><div class="line">  strats[<span class="name">type</span> + <span class="symbol">'s</span>'] = mergeAssets</div><div class="line">&#125;)</div><div class="line"></div><div class="line">function mergeAssets (<span class="name">parentVal</span>, childVal) &#123;</div><div class="line">    // 创建对象并把parentVal放到对象的prototype中</div><div class="line">    var res = Object.create(<span class="name">parentVal</span> || null)</div><div class="line">    return childVal</div><div class="line">        // 如果当前类或实例中存在对应的参数，则合并到新创建的对象中</div><div class="line">        ? extend(<span class="name">res</span>, guardArrayAssets(<span class="name">childVal</span>))</div><div class="line">        否则直接返回新创建的对象</div><div class="line">        : res</div><div class="line">&#125;</div><div class="line">// 将数组形式的数据转换成对象形式的数据</div><div class="line">function guardArrayAssets (<span class="name">assets</span>) &#123;</div><div class="line">    if (<span class="name">isArray</span>(<span class="name">assets</span>)) &#123;</div><div class="line">        var res = &#123;&#125;</div><div class="line">        var i = assets.length</div><div class="line">        var asset</div><div class="line">        while (<span class="name">i--</span>) &#123;</div><div class="line">            asset = assets[<span class="name">i</span>]</div><div class="line">            var id = typeof asset === <span class="symbol">'function</span>'</div><div class="line">                ? ((<span class="name">asset.options</span> &amp;&amp; asset.options.name) || asset.id)</div><div class="line">                : (<span class="name">asset.name</span> || asset.id)</div><div class="line">            if (<span class="name">!id</span>) &#123;</div><div class="line">                process.env.NODE_ENV !== <span class="symbol">'production</span>' &amp;&amp; warn(</div><div class="line">                <span class="symbol">'Array-syntax</span> assets must provide a <span class="string">"name"</span> or <span class="string">"id"</span> field.')</div><div class="line">            &#125; else &#123;</div><div class="line">                res[<span class="name">id</span>] = asset</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res</div><div class="line">    &#125;</div><div class="line">    return assets</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>其它参数采用默认处理策略</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> defaultStrat = <span class="function"><span class="keyword">function</span> (<span class="params">parentVal, childVal</span>) </span>&#123;</div><div class="line">    <span class="comment">// 优先选择当前组件的配置</span></div><div class="line">    <span class="keyword">return</span> childVal === <span class="literal">undefined</span></div><div class="line">        ? parentVal</div><div class="line">        : childVal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-生命周期]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br><code>/src/instance/internal.js</code> &amp; <code>/src/instance/api.js</code></p>
</blockquote>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-类的初始化入口]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br><code>/src/instance/vue.js</code></p>
</blockquote>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>类的初始化过程中，主要绑定在类实例化过程中所需要用到的功能<br>这些功能分拆为两部分，一部分提供给类内部使用，一部分是暴露给外部的api<br>从目录命名也可看出功能划分，internal目录存放内部方法，api目录存放对外暴露的方法  </p>
<a id="more"></a>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import initMixin from <span class="string">'./internal/init'</span></div><div class="line">import stateMixin from <span class="string">'./internal/state'</span></div><div class="line">import eventsMixin from <span class="string">'./internal/events'</span></div><div class="line">import lifecycleMixin from <span class="string">'./internal/lifecycle'</span></div><div class="line">import miscMixin from <span class="string">'./internal/misc'</span></div><div class="line"></div><div class="line">import dataAPI from <span class="string">'./api/data'</span></div><div class="line">import domAPI from <span class="string">'./api/dom'</span></div><div class="line">import eventsAPI from <span class="string">'./api/events'</span></div><div class="line">import lifecycleAPI from <span class="string">'./api/lifecycle'</span></div><div class="line"></div><div class="line"><span class="comment">// Vue构造方法，设计的如此简单也是有原因的：component方法在Vue类的基础上扩展定义类</span></div><div class="line"><span class="comment">// 也就是说Vue中不只存在Vue类，还存在Vue的继承类[占位符]()</span></div><div class="line">function Vue (options) &#123;</div><div class="line">    this._init(options)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 开始扩展类内部使用的方法，这些方法仅做功能块划分(类的初始化顺序)，不代表实例化过程执行顺序</span></div><div class="line"><span class="comment">// 类的实例化入口，执行此方法后被扩展到Vue的prototype上，以_开头</span></div><div class="line"><span class="function"><span class="title">initMixin</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// 参数处理功能，执行此方法后被扩展到Vue的prototype上，以_开头</span></div><div class="line"><span class="function"><span class="title">stateMixin</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// 事件处理功能，执行此方法后被扩展到Vue的prototype上，以_开头</span></div><div class="line"><span class="function"><span class="title">eventsMixin</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// 声明周期功能，执行此方法后被扩展到Vue的prototype上，以_开头</span></div><div class="line"><span class="function"><span class="title">lifecycleMixin</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// 其它功能，执行此方法后被扩展到Vue的prototype上，以_开头</span></div><div class="line"><span class="function"><span class="title">miscMixin</span><span class="params">(Vue)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 有了内部方法才能提供给外部使用，因此先扩展内部方法，再扩展外部方法</span></div><div class="line"><span class="comment">// 实例中数据处理方法，如`$set/$get/$watch`等</span></div><div class="line"><span class="function"><span class="title">dataAPI</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// DOM操作方法，如`$appendTo`等，执行此方法后被扩展到Vue的prototype上，以$开头</span></div><div class="line"><span class="function"><span class="title">domAPI</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// 事件绑定方法，如`$on/$onse`等，执行此方法后被扩展到Vue的prototype上，以$开头</span></div><div class="line"><span class="function"><span class="title">eventsAPI</span><span class="params">(Vue)</span></span></div><div class="line"><span class="comment">// 声明周期方法，如`$mount/$compile`等，其中`$mount`是模板编译的入口，执行此方法后被扩展到Vue的prototype上，以$开头</span></div><div class="line"><span class="function"><span class="title">lifecycleAPI</span><span class="params">(Vue)</span></span></div><div class="line"></div><div class="line">export default Vue</div></pre></td></tr></table></figure>
<h3 id="相关源码解读"><a href="#相关源码解读" class="headerlink" title="相关源码解读"></a>相关源码解读</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-源码入口]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%BA%90%E7%A0%81%E5%85%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br>从入口开始解读Vue源码，让你循序渐进的了解Vue的设计思路及执行过程。<br>Vue源码使用部分ES6语法和功能<br><code>/src/index.js</code></p>
</blockquote>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>导入Vue类的初始化入口，并在Vue类上扩展静态方法  </p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/vue'</span> <span class="comment">// 请阅读 Vue源码解析-类的初始化入口</span></div><div class="line"><span class="keyword">import</span> installGlobalAPI <span class="keyword">from</span> <span class="string">'./global-api'</span> <span class="comment">// 将工具类方法扩展到Vue类上，请阅读Vue源码解析-类方法</span></div><div class="line">installGlobalAPI(Vue)</div><div class="line"><span class="comment">// 指定Vue的当前版本号</span></div><div class="line">Vue.version = <span class="string">'1.0.24'</span></div><div class="line"><span class="comment">// 导出Vue类，类的初始化全部完成</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure>
<h3 id="相关源码解析文章"><a href="#相关源码解析文章" class="headerlink" title="相关源码解析文章"></a>相关源码解析文章</h3><ul>
<li><a href="/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A5%E5%8F%A3/">Vue源码解析-类的初始化入口</a></li>
<li><a href="./Vue源码解析-类方法.md">Vue源码解析-类方法</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-实例化入口]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>version: 1.0.24<br>对源码的解析部分，纯属个人理解(不是纯属虚构)，理解有误或者没有理解透彻的地方，欢迎多拍砖头<br>文件：<code>/src/instance/internal/init.js</code></p>
</blockquote>
<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>原始Vue类的实例化和Vue的子类的实例化的入口都是这里<br>实例化过程中，主要关注各部分功能的实例化顺序<br>源码分析中提到的Vue实例包括Vue的子类实例<br>未进行解读部分为尚未读到或没读明白，嘎嘎。。。脸红了。。  </p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 依赖工具类中的mergeOptions方法，用于处理被传入的参数</span></div><div class="line"><span class="keyword">import</span> &#123; mergeOptions &#125; from <span class="string">'../../util/index'</span></div><div class="line">let uid = <span class="number">0</span> <span class="comment">// 用于Vue实例的唯一标识</span></div><div class="line">export <span class="keyword">default</span> function (Vue) &#123;</div><div class="line">  Vue.prototype._init = function (options) &#123;</div><div class="line">    options = options || &#123;&#125;</div><div class="line">    <span class="keyword">this</span>.$el = <span class="literal">null</span> <span class="comment">// 当前Vue实例对DOM的引用</span></div><div class="line">    <span class="keyword">this</span>.$parent = options.parent <span class="comment">// 当前实例对父级Vue实例的引用(并不是原型链上的父子关系，而是映射到的DOM结构上的父子关系)</span></div><div class="line">    <span class="keyword">this</span>.$root = <span class="keyword">this</span>.$parent <span class="comment">// 当前实例对最外层Vue实例的引用，如果当前实例是最外层，引用自己</span></div><div class="line">      ? <span class="keyword">this</span>.$parent.$root</div><div class="line">      : <span class="keyword">this</span></div><div class="line">    <span class="keyword">this</span>.$children = [] <span class="comment">// DOM结构中处于内层的子级Vue实例(不包含其它后代)所组成的数组</span></div><div class="line">    <span class="keyword">this</span>.$refs = &#123;&#125;       <span class="comment">// 对子级Vue实例中通过`v-ref:xxx`命名过的实例的引用</span></div><div class="line">    <span class="keyword">this</span>.$els = &#123;&#125;        <span class="comment">// 对当前实例对应DOM中通过`v-el:xxx`命名过的子元素的引用，如果子元素命名重名，则返回第一个</span></div><div class="line">    <span class="keyword">this</span>._watchers = []   <span class="comment">// 当前实例中所以Watcher实例所组成的数组</span></div><div class="line">    <span class="keyword">this</span>._directives = [] <span class="comment">// 当前实例中所以Directive实例所组成的数组</span></div><div class="line">    <span class="keyword">this</span>._uid = uid++ <span class="comment">// 实例唯一标记，子类的实例也以此递增，不单独计数</span></div><div class="line">    <span class="keyword">this</span>._isVue = <span class="literal">true</span> <span class="comment">// Vue实例的标记，用于排除Observer对当前实例的监控</span></div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125; <span class="comment">// 对当前实例中事件以及注册到该事件上的回调的记录，事件类型作为key存储</span></div><div class="line">    <span class="keyword">this</span>._eventsCount = &#123;&#125;       <span class="comment">// 事件的数量，事件类型作为key存储</span></div><div class="line"></div><div class="line">    <span class="comment">// fragment instance properties</span></div><div class="line">    <span class="keyword">this</span>._isFragment = <span class="literal">false</span></div><div class="line">    <span class="keyword">this</span>._fragment =         <span class="comment">// @type &#123;DocumentFragment&#125;</span></div><div class="line">    <span class="keyword">this</span>._fragmentStart =    <span class="comment">// @type &#123;Text|Comment&#125;</span></div><div class="line">    <span class="keyword">this</span>._fragmentEnd = <span class="literal">null</span> <span class="comment">// @type &#123;Text|Comment&#125;</span></div><div class="line"></div><div class="line">    <span class="comment">// 当前实例的声明周期状态记录，命名含义清晰的，不多做解释</span></div><div class="line">    <span class="keyword">this</span>._isCompiled =</div><div class="line">    <span class="keyword">this</span>._isDestroyed =</div><div class="line">    <span class="keyword">this</span>._isReady =</div><div class="line">    <span class="keyword">this</span>._isAttached =</div><div class="line">    <span class="keyword">this</span>._isBeingDestroyed =</div><div class="line">    <span class="keyword">this</span>._vForRemoving = <span class="literal">false</span> <span class="comment">// </span></div><div class="line">    <span class="keyword">this</span>._unlinkFn = <span class="literal">null</span> <span class="comment">// </span></div><div class="line"></div><div class="line">    <span class="keyword">this</span>._context = options._context || <span class="keyword">this</span>.$parent</div><div class="line">    <span class="keyword">this</span>._scope = options._scope</div><div class="line">    <span class="keyword">this</span>._frag = options._frag</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._frag) &#123;</div><div class="line">      <span class="keyword">this</span>._frag.children.push(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前实例存在对父级实例的引用，则将自己推入父级实例的$children数组中</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$parent) &#123;</div><div class="line">      <span class="keyword">this</span>.$parent.$children.push(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 参数扩展，将类上参数扩展到实例中，不仅仅是简单的扩展，还会做一些特殊处理</span></div><div class="line">    options = <span class="keyword">this</span>.$options = mergeOptions(</div><div class="line">      <span class="keyword">this</span>.<span class="keyword">constructor</span>.options, <span class="comment">// 挂载在Vue类(或子类)上的options，主要存放组件、指令、元素指令、过滤器、自定义元素、过渡定义和replace的值</span></div><div class="line">      options,</div><div class="line">      <span class="keyword">this</span></div><div class="line">    )</div><div class="line"></div><div class="line">    <span class="comment">// 将自己放入$parent的$refs中，前提是当前Vue实例存在_ref属性(使用v-ref:xxx定义过)</span></div><div class="line">    <span class="comment">// 功能在/src/instance/internal/lifecycle.js中，提取到本文下面解读</span></div><div class="line">    <span class="keyword">this</span>._updateRef()</div><div class="line"></div><div class="line">    <span class="comment">// 初始化_data为空对象，等待_initData时被赋值</span></div><div class="line">    <span class="keyword">this</span>._data = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 触发生命周期中的第一个阶段：init。这里会同步执行参数中放入init字段的回调函数</span></div><div class="line">    <span class="comment">// 具体请看 Vue源码解读-生命周期</span></div><div class="line">    <span class="keyword">this</span>._callHook(<span class="string">'init'</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 处理参数中的props/data/meta/methods/computed，</span></div><div class="line">    <span class="keyword">this</span>._initState()</div><div class="line"></div><div class="line">    <span class="comment">// 处理参数中的events/watch</span></div><div class="line">    <span class="keyword">this</span>._initEvents()</div><div class="line"></div><div class="line">    <span class="comment">// 触发生命周期：created</span></div><div class="line">    <span class="keyword">this</span>._callHook(<span class="string">'created'</span>)</div><div class="line"></div><div class="line">    <span class="comment">// 开始编译，处理视图相关的东东</span></div><div class="line">    <span class="keyword">if</span> (options.el) &#123;</div><div class="line">      <span class="keyword">this</span>.$mount(options.el)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相关源码解读"><a href="#相关源码解读" class="headerlink" title="相关源码解读"></a>相关源码解读</h3><ul>
<li>_updateRef()，存在于声明周期功能中</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// remove：boolean类型，true表示删除，false表示添加</span></div><div class="line">Vue.prototype._updateRef = function (remove) &#123;</div><div class="line">    <span class="comment">// 如果当前实例的$options中存在_ref参数。</span></div><div class="line">    <span class="comment">// 可能存在的情况是组件实例化过程中</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">ref</span> = <span class="keyword">this</span>.$options._<span class="function"><span class="keyword">ref</span></span></div><div class="line">    <span class="title">if</span> (<span class="params"><span class="keyword">ref</span></span>) &#123;</div><div class="line">        <span class="comment">// 将当前实例添加到父级实例的$refs中。</span></div><div class="line">        <span class="comment">// 这里需要考虑的是为什么不是添加到this.$parent.$refs中。。暂时不知道</span></div><div class="line">        <span class="keyword">var</span> refs = (<span class="keyword">this</span>._scope || <span class="keyword">this</span>._context).$<span class="function">refs</span></div><div class="line">        <span class="title">if</span> (<span class="params">remove</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (refs[<span class="keyword">ref</span>] === <span class="keyword">this</span>) &#123;</div><div class="line">                refs[<span class="keyword">ref</span>] = <span class="literal">null</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            refs[<span class="keyword">ref</span>] = <span class="keyword">this</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>_callHook()，存在于事件处理功能中</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._callHook = function (hook) &#123;</div><div class="line">    <span class="comment">// 触发声明周期`前`事件，如：`pre-hook:init`，希望在当前阶段之前被执行的逻辑可以绑定在此事件中</span></div><div class="line">    <span class="keyword">this</span>.$emit(<span class="string">'pre-hook:'</span> + hook)</div><div class="line">    <span class="keyword">var</span> handlers = <span class="keyword">this</span>.$options[hook]</div><div class="line">    <span class="comment">// 在当前实例中遍历执行绑定的当前阶段的处理逻辑</span></div><div class="line">    <span class="keyword">if</span> (handlers) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</div><div class="line">            handlers[i].call(<span class="keyword">this</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 触发声明周期`后`事件，如：`hook:init`，希望在当前阶段的所有钩子函数全部被执行完成之后被执行的逻辑可以绑定在此事件中</span></div><div class="line">    <span class="keyword">this</span>.$emit(<span class="string">'hook:'</span> + hook)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="相关源码解读文章"><a href="#相关源码解读文章" class="headerlink" title="相关源码解读文章"></a>相关源码解读文章</h3><p><a href="">Vue源码解读-生命周期</a>  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-Watchers(数据订阅者)异步执行队列]]></title>
      <url>http://yoursite.com/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-Watchers-%E6%95%B0%E6%8D%AE%E8%AE%A2%E9%98%85%E8%80%85-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<blockquote>
<p>除非当前Watcher被指定为同步执行，或者全局config中的async字段为false（生产环境不建议这样做，影响性能），否则所有的Watchers都被推入异步执行队列。<br>请先阅读<a href="/Vue-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">Vue源码解读-数据的双向绑定简陋版(仅用于原理说明)</a></p>
</blockquote>
<h4 id="订阅者接收到发布者的消息"><a href="#订阅者接收到发布者的消息" class="headerlink" title="订阅者接收到发布者的消息"></a>订阅者接收到发布者的消息</h4><ul>
<li>Watcher在被触发(update方法被调用)时，被推入异步执行队列。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Watcher.js</span></div><div class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.sync || !config.async)&#123; <span class="comment">// 同步的情况</span></div><div class="line">        <span class="keyword">this</span>.run()        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 推入异步执行队列，该方法由队列管理员batcher.js对外暴露</span></div><div class="line">        pushWatcher(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>推入异步执行Watchers队列时，判断当前Watcher是否已经在队列中，在则返回。否则添加到合适的队列中并触发队列中的Watchers执行。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Watcher.js</span></div><div class="line">pushWatcher(watcher)&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">id</span> = watcher.id</div><div class="line">    <span class="comment">// 当前Watcher在队列中，则直接返回</span></div><div class="line">    <span class="keyword">if</span>(has[<span class="keyword">id</span>] == null)&#123; <span class="comment">// 可能为0，所以你懂得</span></div><div class="line">        <span class="comment">// 如果当前Watcher是用户触发，添加到用户Wachers队列，否则添加到指令Watchers队列</span></div><div class="line">        <span class="keyword">const</span> q = watcher.user ? userQueue : queue <span class="comment">// 为啥要分两个队列呢？下面给出解释</span></div><div class="line">        has[<span class="keyword">id</span>] = q.length</div><div class="line">        q.push(watcher)</div><div class="line">        <span class="comment">// 可以保证被推入队列的Watcher被执行到，继续往下看吧</span></div><div class="line">        <span class="keyword">if</span>(!waiting)&#123;</div><div class="line">            waiting = <span class="literal">true</span></div><div class="line">            nexTick(flushBatcherQueue)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Vue维护两条队列，分别存放指令产生的Watchers和用户通过$watch()产生的Watchers。<br>目的是保证指令的Watchers队列在用户Watchers队列之前被执行，保证DOM的可操作性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// batcher.js</span></div><div class="line">let <span class="built_in">queue</span> = [] <span class="comment">// 存放指令Watchers队列</span></div><div class="line">let userQueue = [] <span class="comment">// 存放用户Watchers队列</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">flushBatcherQueue()&#123;</div><div class="line">    runBatcherQueue(<span class="built_in">queue</span>) <span class="comment">// 先执行指令Watchers队列</span></div><div class="line">    runBatcherQueue(userQueue) <span class="comment">// 再执行用户Watchers队列</span></div><div class="line">    <span class="comment">// 当执行用户Watchers队列的时候，可能指令Watchers队列又有新的任务了，因此需要再次执行上线的两个队列，直到两个队列的任务都被执行完。</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>.length) &#123;</div><div class="line">        <span class="keyword">return</span> flushBatcherQueue()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>遍历当前队列中的所有Watchers，并触发Watchers</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// batcher.js</span></div><div class="line"><span class="comment">// 根据传入不同的队列，从而触发不同队列的执行</span></div><div class="line">runBatcherQueue(queue)&#123;</div><div class="line">    <span class="comment">// 这里不能缓存队列的长度，因为在队列中的任务执行的过程中，可能会有新的Wacthers被添加进来，从而保证即waiting为true的时候，不触发nextTick的情况下，依然可以触发不断被添加进来的Watchers</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; i++)&#123;</div><div class="line">        <span class="keyword">var</span> watcher = queue[i]</div><div class="line">        <span class="keyword">var</span> id = watcher.id</div><div class="line">        has[id] = <span class="literal">null</span></div><div class="line">        wacther.run()</div><div class="line">    &#125;</div><div class="line">    queue.length = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码解读-数据的双向绑定简陋版(仅用于原理说明)]]></title>
      <url>http://yoursite.com/Vue-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文通过简化Vue源码，从复杂的Vue源码中抽取数据双向绑定部分的核心进行简化，以便于理解Vue是如何实现数据双向绑定的，其中使用了<br>ES5的Object.defineProperty()<br><code>发布-订阅</code>模式</p>
</blockquote>
<h3 id="监听数据变化"><a href="#监听数据变化" class="headerlink" title="监听数据变化"></a>监听数据变化</h3><ul>
<li>对data进行改造，所有属性设置set&amp;get，用于在属性获取或者设置时，添加逻辑</li>
</ul>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dep用于订阅者的存储和收集，将在下面实现</span></div><div class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'Dep'</span></div><div class="line"><span class="comment">// Observer类用于给data属性添加set&amp;get方法</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(value)&#123;</div><div class="line">        <span class="keyword">this</span>.value = value</div><div class="line">        <span class="keyword">this</span>.walk(value)</div><div class="line">    &#125;</div><div class="line">    walk(value)&#123;</div><div class="line">        <span class="built_in">Object</span>.keys(value).forEach(key =&gt; <span class="keyword">this</span>.convert(key, value[key]))</div><div class="line">    &#125;</div><div class="line">    convert(key, val)&#123;</div><div class="line">        defineReactive(<span class="keyword">this</span>.value, key, val)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">    <span class="comment">// 给当前属性的值添加监听</span></div><div class="line">    <span class="keyword">var</span> chlidOb = observe(val)</div><div class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configurable: <span class="literal">true</span>,</div><div class="line">        get: ()=&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</div><div class="line">            <span class="comment">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></div><div class="line">            <span class="comment">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></div><div class="line">            <span class="comment">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></div><div class="line">            <span class="comment">// 此处的问题是：并不是每次Dep.target有值时都需要添加到订阅者管理员中去管理，需要对订阅者去重，不影响整体思路，不去管它</span></div><div class="line">            <span class="keyword">if</span>(Dep.target)&#123;</div><div class="line">                dep.addSub(Dep.target)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        &#125;,</div><div class="line">        set: (newVal) =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'new value seted'</span>)</div><div class="line">            <span class="keyword">if</span>(val === newVal) <span class="keyword">return</span></div><div class="line">            val = newVal</div><div class="line">            <span class="comment">// 对新值进行监听</span></div><div class="line">            chlidOb = observe(newVal)</div><div class="line">            <span class="comment">// 通知所有订阅者，数值被改变了</span></div><div class="line">            dep.notify()</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="comment">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></div><div class="line">    <span class="keyword">if</span>(!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observer(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="管理订阅者"><a href="#管理订阅者" class="headerlink" title="管理订阅者"></a>管理订阅者</h3><ul>
<li>对订阅者进行收集、存储和通知</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export default class Dep&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.subs = []</div><div class="line">    &#125;</div><div class="line">    addSub(<span class="function"><span class="keyword">sub</span>)</span>&#123;</div><div class="line">        this.subs.push(<span class="function"><span class="keyword">sub</span>)</span></div><div class="line">    &#125;</div><div class="line">    <span class="title">notify</span>()&#123;</div><div class="line">        // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</div><div class="line">        this.subs.forEach((<span class="function"><span class="keyword">sub</span>) =&gt; <span class="title">sub</span>.<span class="title">update</span>())</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h3><ul>
<li>每个订阅者都是对某条数据的订阅</li>
<li>订阅者维护着每一次更新之前的数据，将其和更新之后的数据进行对比，如果发生了变化，则执行相应的业务逻辑，并更新订阅者中维护的数据的值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Dep from <span class="string">'Dep'</span></div><div class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb)&#123;</div><div class="line">        <span class="keyword">this</span>.vm = vm <span class="comment">// 被订阅的数据一定来自于当前Vue实例</span></div><div class="line">        <span class="keyword">this</span>.cb = cb <span class="comment">// 当数据更新时想要做的事情</span></div><div class="line">        <span class="keyword">this</span>.expOrFn = expOrFn <span class="comment">// 被订阅的数据</span></div><div class="line">        <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>() <span class="comment">// 维护更新之前的数据</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></div><div class="line">    update()&#123;</div><div class="line">        <span class="keyword">this</span>.run()</div><div class="line">    &#125;</div><div class="line">    run()&#123;</div><div class="line">        const <span class="keyword">val</span> = <span class="keyword">this</span>.<span class="keyword">get</span>()</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">val</span> !== <span class="keyword">this</span>.<span class="keyword">val</span>)&#123;</div><div class="line">            <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>;</div><div class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">get</span>()&#123;</div><div class="line">        <span class="comment">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></div><div class="line">        Dep.target = <span class="keyword">this</span></div><div class="line">        const <span class="keyword">val</span> = <span class="keyword">this</span>.vm._data[<span class="keyword">this</span>.expOrFn]</div><div class="line">        <span class="comment">// 置空，用于下一个Watcher使用</span></div><div class="line">        Dep.target = <span class="literal">null</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">val</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul>
<li>将数据代理到Vue实例上，真实数据存储于实例的_data属性中</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Observer, &#123;observe&#125; from <span class="string">'Observer'</span></div><div class="line"><span class="keyword">import</span> Watcher from <span class="string">'Watcher'</span></div><div class="line"></div><div class="line"></div><div class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Vue</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;)&#123;</div><div class="line">        <span class="comment">// 简化了$options的处理</span></div><div class="line">        <span class="keyword">this</span>.$options = options</div><div class="line">        <span class="comment">// 简化了对data的处理</span></div><div class="line">        let <span class="keyword">data</span> = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.<span class="keyword">data</span></div><div class="line">        <span class="comment">// 将所有data最外层属性代理到Vue实例上</span></div><div class="line">        Object.keys(<span class="keyword">data</span>).forEach(key =&gt; <span class="keyword">this</span>._proxy(key))</div><div class="line">        <span class="comment">// 监听数据</span></div><div class="line">        observe(<span class="keyword">data</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></div><div class="line">    $watch(expOrFn, cb)&#123;</div><div class="line">        new Watcher(<span class="keyword">this</span>, expOrFn, cb)</div><div class="line">    &#125;</div><div class="line">    _proxy(key)&#123;</div><div class="line">        Object.defineProperty(<span class="keyword">this</span>, key, &#123;</div><div class="line">            configurable: <span class="literal">true</span>,</div><div class="line">            enumerable: <span class="literal">true</span>,</div><div class="line">            <span class="keyword">get</span>: () =&gt; <span class="keyword">this</span>._data[key],</div><div class="line">            <span class="keyword">set</span>: (<span class="keyword">val</span>) =&gt; &#123;</div><div class="line">                <span class="keyword">this</span>._data[key] = <span class="keyword">val</span></div><div class="line">            &#125; </div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="调用这个极简版演示数据双向绑定原理的Vue"><a href="#调用这个极简版演示数据双向绑定原理的Vue" class="headerlink" title="调用这个极简版演示数据双向绑定原理的Vue"></a>调用这个极简版演示数据双向绑定原理的Vue</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue from <span class="string">'./Vue'</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> demo = <span class="literal">new</span> Vue(&#123;</div><div class="line">    <span class="built_in">data</span>: &#123;</div><div class="line">        <span class="string">'a'</span>: &#123;</div><div class="line">            <span class="string">'ab'</span>: &#123;</div><div class="line">                <span class="string">'c'</span>: <span class="string">'C'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">'b'</span>: &#123;</div><div class="line">            <span class="string">'bb'</span>: <span class="string">'BB'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">'c'</span>: <span class="string">'C'</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">demo.$watch(<span class="string">'c'</span>, () =&gt; console.<span class="keyword">log</span>(<span class="string">'c is changed'</span>))</div><div class="line"><span class="comment">// get value</span></div><div class="line">demo.c = <span class="string">'CCC'</span></div><div class="line"><span class="comment">// new value seted</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// c is changed</span></div><div class="line">demo.c = <span class="string">'DDD'</span></div><div class="line"><span class="comment">// new value seted</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// c is changed</span></div><div class="line">demo.a</div><div class="line"><span class="comment">// get value</span></div><div class="line">demo.a.ab = &#123;</div><div class="line">    <span class="string">'d'</span>: <span class="string">'D'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// new value seted</span></div><div class="line">console.<span class="keyword">log</span>(demo.a.ab)</div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// &#123;get d: (), set d: ()&#125;</span></div><div class="line">demo.a.ab.d = <span class="string">'DD'</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// new value seted</span></div><div class="line">console.<span class="keyword">log</span>(demo.a.ab);</div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// get value</span></div><div class="line"><span class="comment">// &#123;get d: (), set d: ()&#125;</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Symbol]]></title>
      <url>http://yoursite.com/Symbol/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一种新的原始数据类型，表示独一无二的值。它是JavaScript语言的第七种数据类型。</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>表示独一无二的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>();</div><div class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>新的原始数据类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">typeof</span> a; <span class="comment">// "symbol"</span></div></pre></td></tr></table></figure>
<ul>
<li>不能使用new关键字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// 报错：Uncaught TypeError: Symbol is not a constructor</span></div></pre></td></tr></table></figure>
<ul>
<li>可以接受一个字符串作为参数，表示对Symbol实例的描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>); <span class="comment">// Symbol(a)</span></div><div class="line">a.toString() <span class="comment">// "Symbol(a)"</span></div></pre></td></tr></table></figure>
<ul>
<li>Symbol值不能与其他类型的值进行运算</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</div><div class="line"><span class="string">'hello '</span> + a; <span class="comment">// 报错：Cannot convert a Symbol value to a string</span></div><div class="line">\`hello $&#123;a&#125;\`; <span class="comment">// 报错：Cannot convert a Symbol value to a string</span></div></pre></td></tr></table></figure>
<ul>
<li>Symbol值可以显式转为字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</div><div class="line"><span class="built_in">String</span>(a); <span class="comment">// "Symbol(a)"</span></div><div class="line">a.toString(); <span class="comment">// "Symbol(a)"</span></div></pre></td></tr></table></figure>
<ul>
<li>Symbol值也可以转为布尔值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</div><div class="line"><span class="built_in">Boolean</span>(a); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<ul>
<li>不能转为数值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</div><div class="line"><span class="built_in">Number</span>(a); <span class="comment">// 报错：Cannot convert a Symbol value to a number</span></div></pre></td></tr></table></figure>
<h3 id="作为对象属性名"><a href="#作为对象属性名" class="headerlink" title="作为对象属性名"></a>作为对象属性名</h3><ul>
<li>作为属性名的几种写法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">obj[a] = <span class="string">'hello'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    [a]: <span class="string">'hello'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj, a, &#123;</div><div class="line">    value: <span class="string">'hello'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>Symbol值作为对象属性名时，不能用点运算符，因为点运算符后面总是字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"></div><div class="line">obj.a = <span class="string">'hello'</span>;</div><div class="line">obj[a] <span class="comment">// undefined</span></div><div class="line">obj[<span class="string">'a'</span>] <span class="comment">// "hello"</span></div></pre></td></tr></table></figure>
<ul>
<li>不能被for…in、for…of遍历，也不会被Object.keys()、Object.getOwnPropertyNames()等方法返回，可以通过Object.getOwnPropertySymbols()获取，或者通过Reflect.ownKey(属于ES7的范畴，它代理了大部分的Object功能，对它不再继续深入，有兴趣的同学可以自行查阅资料)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    [<span class="built_in">Symbol</span>(<span class="string">'a'</span>)]: <span class="string">'a'</span>,</div><div class="line">    [<span class="built_in">Symbol</span>(<span class="string">'b'</span>)]: <span class="string">'b'</span>,</div><div class="line">    c: <span class="string">'c'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj); <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj); <span class="comment">// [Symbol(a), Symbol(b)]</span></div><div class="line"></div><div class="line"><span class="built_in">Reflect</span>.ownKeys(obj); <span class="comment">// ["c", Symbol(a), Symbol(b)]</span></div></pre></td></tr></table></figure>
<h3 id="Symbol方法和内置Symbol值"><a href="#Symbol方法和内置Symbol值" class="headerlink" title="Symbol方法和内置Symbol值"></a>Symbol方法和内置Symbol值</h3><h4 id="for"><a href="#for" class="headerlink" title="for()"></a>for()</h4><ul>
<li>使用for方法可以获取相同Symbol值的不同变量</li>
<li>传入的字符串需要相同，可以为空</li>
<li>必须全为for定义</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>.<span class="keyword">for</span>();</div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>.<span class="keyword">for</span>();</div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'c'</span>);</div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'c'</span>);</div><div class="line"><span class="keyword">var</span> e = <span class="built_in">Symbol</span>(<span class="string">'e'</span>);</div><div class="line"><span class="keyword">var</span> f = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'e'</span>);</div><div class="line"></div><div class="line">a === b; <span class="comment">// true</span></div><div class="line">c === d; <span class="comment">// true</span></div><div class="line">e === f; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h4 id="keyFor"><a href="#keyFor" class="headerlink" title="keyFor()"></a>keyFor()</h4><ul>
<li>返回一个已登记的Symbol类型值的key</li>
<li>只有通过for方法生成的Symbol才能使用该方法返回key</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'a'</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(a); <span class="comment">// 'a'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>); <span class="comment">// 未登记</span></div><div class="line"><span class="built_in">Symbol</span>.keyFor(a); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h4 id="hasInstance"><a href="#hasInstance" class="headerlink" title="hasInstance"></a>hasInstance</h4><ul>
<li>此方法至少暂时不可用，最新版的chrome和node中均不能正常工作</li>
<li>该方法会被instanceof运算符调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](foo)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">[] <span class="keyword">instanceof</span> Demo <span class="comment">// 理论上返回true，但是实际chrome中测试返回false</span></div></pre></td></tr></table></figure>
<h4 id="isConcatSpreadable"><a href="#isConcatSpreadable" class="headerlink" title="isConcatSpreadable"></a>isConcatSpreadable</h4><ul>
<li>对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。</li>
</ul>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var a = [<span class="string">'a'</span>]; // 数组的<span class="symbol">Symbol</span>.isConcatSpreadable属性默认值为true</div><div class="line">[<span class="string">'b'</span>].concat(a, <span class="string">'c'</span>); // [<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>]</div><div class="line"></div><div class="line">var a = [<span class="string">'a'</span>];</div><div class="line">a[<span class="symbol">Symbol</span>.isConcatSpreadable] = false;</div><div class="line">[<span class="string">'b'</span>].concat(a, <span class="string">'c'</span>); // [<span class="string">'b'</span>, [<span class="string">'a'</span>], <span class="string">'c'</span>]</div><div class="line"></div><div class="line">var a = &#123;</div><div class="line">    <span class="number">0</span>: <span class="string">'a'</span>,</div><div class="line">    length: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line">[<span class="string">'c'</span>].concat(a, <span class="string">'d'</span>); // [<span class="string">'c'</span>, &#123;<span class="number">0</span>: <span class="string">'a'</span>, length: <span class="number">1</span>&#125;, <span class="string">'d'</span>]</div><div class="line">a[<span class="symbol">Symbol</span>.isConcatSpreadable] = true;</div><div class="line">[<span class="string">'c'</span>].concat(a, <span class="string">'d'</span>); // [<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</div></pre></td></tr></table></figure>
<ul>
<li>这种方法是行不通的，至少我验证了最新的chrome和最新版的node，都无法正常工作</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;[<span class="type">Symbol</span>.isConcatSpreadable]()&#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="type">Demo</span>('a');</div><div class="line">['b'].concat(a); <span class="comment">// ['b', 'a']</span></div></pre></td></tr></table></figure>
<h4 id="species"><a href="#species" class="headerlink" title="species"></a>species</h4><ul>
<li>蛋疼啊。。。。</li>
<li>最新版Chrome和node中验证失败</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.props = props</div><div class="line">    &#125;</div><div class="line">    [<span class="built_in">Symbol</span>.species]()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Demo(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, i, arr</span>)</span>&#123; <span class="comment">// 都是一个不同的数组了，咋可能还是Demo的实例呢！</span></div><div class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">b <span class="keyword">instanceof</span> Demo; <span class="comment">// 他们说这个地方应该返回true，但实际上返回false</span></div><div class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</div></pre></td></tr></table></figure>
<h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><ul>
<li>指定字符串调用match方法时的行为</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Match</span></span>&#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        <span class="keyword">this</span>.props = props || <span class="symbol">'hell</span>o'</div><div class="line">    &#125;</div><div class="line">    [<span class="type">Symbol</span>.<span class="keyword">match</span>](string)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.<span class="keyword">match</span>(string);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="keyword">match</span> = <span class="keyword">new</span> <span class="type">Match</span>();</div><div class="line">'e'.<span class="keyword">match</span>(<span class="keyword">match</span>); <span class="comment">// ['e']</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> <span class="keyword">match</span> = <span class="keyword">new</span> <span class="type">Match</span>(<span class="symbol">'11</span>1');</div><div class="line">'e'.<span class="keyword">match</span>(<span class="keyword">match</span>); <span class="comment">// null</span></div></pre></td></tr></table></figure>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><ul>
<li>指定字符串调用replace方法时的行为</li>
</ul>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class <span class="title">Replace</span>&#123;</div><div class="line">    [<span class="built_in">Symbol</span>.replace](<span class="built_in">string</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">string</span>); <span class="comment">// 还可以干点别的哦。。</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.replace(<span class="regexp">/b/g</span>, <span class="string">'a'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">var</span> replace = <span class="keyword">new</span> Replace();</div><div class="line"><span class="string">'abaaaab'</span>.replace(replace); <span class="comment">// 'aaaaaaa'</span></div></pre></td></tr></table></figure>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><ul>
<li>指定字符串调用search方法时的行为</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Search</span>&#123;</div><div class="line">    [Symbol.search](<span class="keyword">string</span>)&#123;</div><div class="line">        <span class="keyword">string</span> = <span class="string">'aaaaab'</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.search(/b/g);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> search = <span class="keyword">new</span> Search();</div><div class="line"><span class="string">'abaaaab'</span>.search(search); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><ul>
<li>指定字符串调用split方法时的行为</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="keyword">Split</span>&#123;</div><div class="line">    [Symbol.<span class="keyword">split</span>](string)&#123;</div><div class="line">        <span class="keyword">return</span> string.<span class="keyword">split</span>('b', 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="keyword">split</span> = new <span class="keyword">Split</span>();</div><div class="line">'abaaaab'.<span class="keyword">split</span>(<span class="keyword">split</span>); <span class="comment">// ['a']</span></div></pre></td></tr></table></figure>
<h4 id="toPrimitive"><a href="#toPrimitive" class="headerlink" title="toPrimitive"></a>toPrimitive</h4><ul>
<li>当数据被进行类型转换时，调用该数据的Symbol.toPrimitive方法</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    [Symbol.toPrimitive](<span class="keyword">type</span>)&#123;</div><div class="line">        <span class="keyword">switch</span>(<span class="keyword">type</span>)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'string'</span>: <span class="comment">// 只能转换成string时</span></div><div class="line">                <span class="keyword">return</span> <span class="string">'aaa'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'number'</span>: <span class="comment">// 只能转换成number时</span></div><div class="line">                <span class="keyword">return</span> <span class="number">123</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">'default'</span>: <span class="comment">// 既可以转换成string，又可以转换成number时</span></div><div class="line">                <span class="keyword">return</span> <span class="string">'default'</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></div><div class="line"><span class="string">'a'</span> + obj <span class="comment">// 'adefault'</span></div><div class="line"><span class="built_in">String</span>(obj) <span class="comment">// 'aaa'</span></div></pre></td></tr></table></figure>
<h4 id="toStringTag"><a href="#toStringTag" class="headerlink" title="toStringTag"></a>toStringTag</h4><ul>
<li>控制在调用toString方法时返回的字符串</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">get</span> [<span class="built_in">Symbol</span>.toStringTag]()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'Demo'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Demo();</div><div class="line">a.toString(); <span class="comment">// "[object Demo]"</span></div></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="消除魔术字符串"><a href="#消除魔术字符串" class="headerlink" title="消除魔术字符串"></a>消除魔术字符串</h4><blockquote>
<p>在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。</p>
</blockquote>
<ul>
<li>魔术字符串的栗子</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(str)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'abc'</span>: <span class="comment">// 魔术字符串</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'hello Symbol'</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">demo(<span class="string">'abc'</span>); <span class="comment">// 魔术字符串</span></div></pre></td></tr></table></figure>
<ul>
<li>消除魔术字符串的方法，把它变成一个变量。大家都懂的，就没栗子了</li>
<li>但是，上面栗子上’abc’字符串真的有实际意义吗？是否可以这样？当然也是需要赋值给一个变量</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>); <span class="comment">// 传字符串'a'只是为了方便查看下面的打印结果，其实可以不传</span></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</div><div class="line">function demo(v)&#123;</div><div class="line">    <span class="keyword">switch</span>(v)&#123;</div><div class="line">        <span class="keyword">case</span> a: </div><div class="line">            console.log(\`hello <span class="built_in">Symbol</span>, I am $&#123;<span class="built_in">String</span>(a)&#125;\`); <span class="comment">// ES6的模板功能，下次再带大家认识。</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> b: </div><div class="line">            console.log(\`hello <span class="built_in">Symbol</span>, I am $&#123;<span class="built_in">String</span>(b)&#125;\`);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">demo(a);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[String]]></title>
      <url>http://yoursite.com/String/</url>
      <content type="html"><![CDATA[<blockquote>
<p>可以重点关注模板字符串</p>
</blockquote>
<h3 id="支持超过-u0000——-uFFFF的Unicode表示法"><a href="#支持超过-u0000——-uFFFF的Unicode表示法" class="headerlink" title="支持超过\u0000——\uFFFF的Unicode表示法"></a>支持超过\u0000——\uFFFF的Unicode表示法</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="string">'\u&#123;20BB7&#125;'</span>); <span class="regexp">//</span> ES6 <span class="string">"𠮷"</span></div><div class="line">alert(<span class="string">'\u20BB7'</span>); <span class="regexp">//</span> <span class="string">" 7"</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true</span></div><div class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></div><div class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></div><div class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></div><div class="line"><span class="string">'\u&#123;7A&#125;'</span> === <span class="string">'z'</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><h3 id="fromCodePoint"><a href="#fromCodePoint" class="headerlink" title="fromCodePoint()"></a>fromCodePoint()</h3><h3 id="for…of-遍历字符串"><a href="#for…of-遍历字符串" class="headerlink" title="for…of(遍历字符串)"></a>for…of(遍历字符串)</h3><ul>
<li>字符串拥有Symbol.iterator属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(codePoint)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><ul>
<li>‘𠮷’这个字不是’吉’</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.at<span class="comment">(0)</span> <span class="comment">// 'a'</span></div><div class="line"><span class="string">'𠮷'</span>.at<span class="comment">(0)</span> <span class="comment">// '陈'</span></div></pre></td></tr></table></figure>
<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><h3 id="startsWith-str-index"><a href="#startsWith-str-index" class="headerlink" title="startsWith(str [,index])"></a>startsWith(str [,index])</h3><ul>
<li>s.startsWith(‘xxx’, 6);</li>
</ul>
<h3 id="endsWith-str-index"><a href="#endsWith-str-index" class="headerlink" title="endsWith(str [,index])"></a>endsWith(str [,index])</h3><h3 id="includes-str-index"><a href="#includes-str-index" class="headerlink" title="includes(str [,index])"></a>includes(str [,index])</h3><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><ul>
<li>‘hello’.repeat(3) // hellohellohello</li>
</ul>
<h3 id="padStart"><a href="#padStart" class="headerlink" title="padStart()"></a>padStart()</h3><ul>
<li>ES7</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></div><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></div></pre></td></tr></table></figure>
<h3 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h3><ul>
<li>ES7</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></div></pre></td></tr></table></figure>
<h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h3><ul>
<li>‘`’ 反引号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> demo = &#123;</div><div class="line">  a: <span class="string">'aaa'</span>,</div><div class="line">  b: <span class="string">'bbb'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">`</span></div><div class="line">  There are <span class="subst">$&#123;demo.a&#125;</span> items</div><div class="line">   in your basket, <span class="subst">$&#123;demo.b&#125;</span></div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const data = [</div><div class="line">    &#123; <span class="built_in">first</span>: '&lt;Jane&gt;', <span class="built_in">last</span>: 'Bond' &#125;,</div><div class="line">    &#123; <span class="built_in">first</span>: 'Lars', <span class="built_in">last</span>: '&lt;Croft&gt;' &#125;,</div><div class="line">];</div><div class="line">const tmpl = addrs =&gt; `</div><div class="line">  &lt;table&gt;</div><div class="line">  $&#123;addrs.<span class="built_in">map</span>(addr =&gt; `</div><div class="line">    &lt;<span class="built_in">tr</span>&gt;&lt;td&gt;$&#123;addr.<span class="built_in">first</span>&#125;&lt;/td&gt;&lt;/<span class="built_in">tr</span>&gt;</div><div class="line">    &lt;<span class="built_in">tr</span>&gt;&lt;td&gt;$&#123;addr.<span class="built_in">last</span>&#125;&lt;/td&gt;&lt;/<span class="built_in">tr</span>&gt;</div><div class="line">  `).<span class="built_in">join</span>('')&#125;</div><div class="line">  &lt;/table&gt;</div><div class="line">`;</div><div class="line">console.<span class="built_in">log</span>(tmpl(data));</div></pre></td></tr></table></figure>
<h3 id="raw"><a href="#raw" class="headerlink" title="raw()"></a>raw()</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Set]]></title>
      <url>http://yoursite.com/Set/</url>
      <content type="html"><![CDATA[<blockquote>
<p>它类似于数组，但是成员的值都是唯一的，没有重复的值。  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].map(x =&gt; s.add(x));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 3 5 4</span></div></pre></td></tr></table></figure>
<blockquote>
<p>向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。<br>对于引用了同一个对象的不同变量，会被认为是相同的值。</p>
</blockquote>
<a id="more"></a>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><ul>
<li>返回Set实例的成员总数。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var a = new Set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]);</div><div class="line">console.log(a.size); <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<h3 id="add-value"><a href="#add-value" class="headerlink" title="add(value)"></a>add(value)</h3><ul>
<li>添加某个值，返回Set结构本身。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line"><span class="built_in">console</span>.log(a.add(<span class="string">'a'</span>)); <span class="comment">// Set &#123;'a'&#125;</span></div></pre></td></tr></table></figure>
<h3 id="delete-value"><a href="#delete-value" class="headerlink" title="delete(value)"></a>delete(value)</h3><ul>
<li>删除某个值，返回一个布尔值，表示删除是否成功。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>]);</div><div class="line"><span class="built_in">console</span>.log(a.delete(<span class="string">'a'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Set &#123;'b', 'c'&#125;</span></div></pre></td></tr></table></figure>
<h3 id="has-value"><a href="#has-value" class="headerlink" title="has(value)"></a>has(value)</h3><ul>
<li>返回一个布尔值，表示该值是否为Set的成员。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"><span class="built_in">console</span>.log(a.has(<span class="string">'a'</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(a.has(<span class="string">'c'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><ul>
<li>清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</div><div class="line"><span class="built_in">console</span>.log(a.clear()); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Set &#123;&#125;</span></div></pre></td></tr></table></figure>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h3><ul>
<li>返回一个键名的遍历器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"><span class="built_in">console</span>.log(a.keys()); <span class="comment">// SetIterator &#123;'a'， 'b'&#125;</span></div></pre></td></tr></table></figure>
<h3 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h3><ul>
<li>返回一个键值的遍历器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"><span class="built_in">console</span>.log(a.values()); <span class="comment">// SetIterator &#123;'a', 'b'&#125;</span></div></pre></td></tr></table></figure>
<h3 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h3><ul>
<li>返回一个键值对的遍历器</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"><span class="built_in">console</span>.log(a.entries()); <span class="comment">// SetIterator &#123;['a', 'a'], ['b', 'b']&#125;</span></div></pre></td></tr></table></figure>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ul>
<li>使用回调函数遍历每个成员</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = new <span class="keyword">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line">a.forEach(function(value, key, <span class="keyword">set</span>)&#123;</div><div class="line">    console.log(<span class="keyword">value</span>, <span class="keyword">key</span>, <span class="keyword">set</span>); // a a <span class="keyword">Set</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;; b b <span class="keyword">Set</span> &#123;<span class="string">'a'</span>, <span class="string">'b'</span>&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><ul>
<li>so easy~~，妈妈再也不用担心数组去重</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var origin = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>];</div><div class="line">var unique = [...new Set(origin)] <span class="comment">// [1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Promise]]></title>
      <url>http://yoursite.com/Promise/</url>
      <content type="html"><![CDATA[<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="创建Promise实例"><a href="#创建Promise实例" class="headerlink" title="创建Promise实例"></a>创建Promise实例</h4><ul>
<li>demo</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    <span class="comment">// ... some code</span></div><div class="line">    <span class="keyword">if</span>(<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">        resolve(value);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        reject(error);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="实例方法：then"><a href="#实例方法：then" class="headerlink" title="实例方法：then()"></a>实例方法：then()</h4><ul>
<li>第一个参数是成功回调，状态为resolved时被调用</li>
<li>第二个参数是失败回调，状态为rejceted时被调用</li>
<li>尽量不要使用第二个参数处理失败回调，而是使用catch()</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="keyword">data</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">data</span>;</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(error)</span></span>&#123;</div><div class="line">    console.<span class="built_in">log</span>(error);</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="keyword">data</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="实例方法：catch"><a href="#实例方法：catch" class="headerlink" title="实例方法：catch()"></a>实例方法：catch()</h4><ul>
<li>.then(function(null, errorCallback){})的别名，只处理异常情况</li>
<li>执行then方法时的报错，也会被catch捕获</li>
</ul>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></div><div class="line">    aaaaa</div><div class="line">    console.<span class="built_in">log</span>(data);</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>); <span class="comment">// aaaaa is not defined</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="静态方法：all"><a href="#静态方法：all" class="headerlink" title="静态方法：all()"></a>静态方法：all()</h4><ul>
<li>参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajaxs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> $http.get(<span class="string">'/get/'</span> + id);</div><div class="line">&#125;)</div><div class="line">Promise.all(ajaxs).then(<span class="function"><span class="keyword">function</span><span class="params">(datas)</span></span>&#123; <span class="comment">// 数组</span></div><div class="line">    </div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span></span>&#123; <span class="comment">// 第一个失败的异步方法返回值</span></div><div class="line">    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="静态方法：trace"><a href="#静态方法：trace" class="headerlink" title="静态方法：trace()"></a>静态方法：trace()</h4><ul>
<li>用法同all()</li>
<li>不同的是，不是多个Promise方法全部返回之后触发成功或失败，而是返回结果比较快的那个Promise方法决定成功或失败</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> demo = <span class="built_in">Promise</span>.race([</div><div class="line">    fetch(<span class="string">'xxx.json'</span>),</div><div class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        setTimeout(() =&gt; reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</div><div class="line">    &#125;)</div><div class="line">]);</div><div class="line">demo.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// fetch如果在5000ms以内返回时执行</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// fetch如果在5000ms以内未返回时执行</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="静态方法：resolve"><a href="#静态方法：resolve" class="headerlink" title="静态方法：resolve()"></a>静态方法：resolve()</h4><ul>
<li>将现有对象转换为Promise对象</li>
</ul>
<h4 id="静态方法：reject"><a href="#静态方法：reject" class="headerlink" title="静态方法：reject()"></a>静态方法：reject()</h4><ul>
<li>将现有对象转换为Promise对象</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="一个通过Promise实现的ajax请求"><a href="#一个通过Promise实现的ajax请求" class="headerlink" title="一个通过Promise实现的ajax请求"></a>一个通过Promise实现的ajax请求</h4><ul>
<li>仅做Promise用法说明，未进行验证兼容性验证</li>
</ul>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> $http = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> core = &#123;</div><div class="line">        ajax(method, <span class="built_in">url</span>, args)&#123;</div><div class="line">            <span class="keyword">const</span> promise = <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">                <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">                <span class="keyword">let</span> uri = <span class="built_in">url</span>;</div><div class="line">                <span class="keyword">let</span> params = <span class="string">''</span>;</div><div class="line">                <span class="keyword">let</span> argCount = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> args)&#123;</div><div class="line">                    <span class="keyword">if</span>(args.hasOwnProperty(key))&#123;</div><div class="line">                        <span class="keyword">if</span>(argCount++)&#123;</div><div class="line">                            params += <span class="string">'&amp;'</span>;</div><div class="line">                        &#125;</div><div class="line">                        params += <span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(args[key]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(method === <span class="string">'GET'</span>)&#123;</div><div class="line">                    uri += <span class="string">'?'</span> + params;</div><div class="line">                &#125;</div><div class="line">                client.open(method, uri, <span class="literal">true</span>);</div><div class="line">                client.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line">                client.send(method === <span class="string">'GET'</span> ? <span class="attribute">null</span> : params);</div><div class="line">                client.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt; <span class="number">300</span>)&#123;</div><div class="line">                        resolve(<span class="keyword">this</span>.response);</div><div class="line">                    &#125;<span class="title">else</span>&#123;</div><div class="line">                        reject(<span class="keyword">this</span>.statusText);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                client.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    reject(<span class="keyword">this</span>.statusText);</div><div class="line">                &#125;;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        get(<span class="built_in">url</span>, args)&#123;</div><div class="line">            <span class="keyword">return</span> core.ajax(<span class="string">'GET'</span>, <span class="built_in">url</span>, args);</div><div class="line">        &#125;,</div><div class="line">        post(<span class="built_in">url</span>, args)&#123;</div><div class="line">            <span class="keyword">return</span> core.ajax(<span class="string">'POST'</span>, <span class="built_in">url</span>, args);</div><div class="line">        &#125;,</div><div class="line">        ajax(method, <span class="built_in">url</span>, args)&#123;</div><div class="line">            <span class="keyword">return</span> core.ajax(method, <span class="built_in">url</span>, args);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 使用</span></div><div class="line">$http.post(<span class="string">'js/content.js'</span>, &#123;</div><div class="line">    <span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'b'</span>: <span class="number">2</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="与Generator结合"><a href="#与Generator结合" class="headerlink" title="与Generator结合"></a>与Generator结合</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Object]]></title>
      <url>http://yoursite.com/Object/</url>
      <content type="html"><![CDATA[<h3 id="属性的简单表示法"><a href="#属性的简单表示法" class="headerlink" title="属性的简单表示法"></a>属性的简单表示法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</div><div class="line"><span class="keyword">var</span> bar = &#123;foo&#125;; <span class="comment">// bar = &#123;foo: 'foo'&#125;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</div><div class="line">&#125;</div><div class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;x: 1, y: 2&#125;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="方法的简写"><a href="#方法的简写" class="headerlink" title="方法的简写"></a>方法的简写</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    method()&#123; <span class="comment">// 省略'function'关键字</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'hello'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    [foo]: <span class="literal">true</span>,</div><div class="line">    [<span class="string">'a'</span> + <span class="string">'b'</span>]: <span class="number">1</span>,</div><div class="line">    <span class="string">\['h'</span> + <span class="string">'ello'</span><span class="string">\]()&#123;</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'hi'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="is"><a href="#is" class="headerlink" title="is()"></a>is()</h3><ul>
<li>没啥大作用</li>
</ul>
<h2 id="assign-target-…source"><a href="#assign-target-…source" class="headerlink" title="assign(target, …source)"></a>assign(target, …source)</h2><ul>
<li>将源对象（source）的所有可枚举属性，复制到目标对象（target）。</li>
<li>如果该参数不是对象，则会先转成对象，然后返回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object" Number对象</span></div></pre></td></tr></table></figure>
<ul>
<li>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</li>
<li>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</li>
</ul>
<figure class="highlight cal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = Object.assign(&#123;&#125;, v1, v2, v3);</div><div class="line">console.log(obj); // &#123; <span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>: <span class="string">"b"</span>, <span class="string">"2"</span>: <span class="string">"c"</span> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>浅拷贝</li>
</ul>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="comment">&#123;a: &#123;b: 1&#125;</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = <span class="keyword">Object</span>.assign(<span class="comment">&#123;&#125;</span>, obj1);</div><div class="line"></div><div class="line">obj1.a.b = <span class="number">2</span>;</div><div class="line">obj2.a.b <span class="comment">// 2</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Map]]></title>
      <url>http://yoursite.com/Map/</url>
      <content type="html"><![CDATA[<blockquote>
<p>键值对的集合</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="keyword">var</span> o = &#123;p: <span class="string">"Hello World"</span>&#125;;</div><div class="line"></div><div class="line">m.<span class="keyword">set</span>(o, <span class="string">"content"</span>)</div><div class="line">m.<span class="keyword">get</span>(o) <span class="comment">// "content"</span></div><div class="line"></div><div class="line">m.has(o) <span class="comment">// true</span></div><div class="line">m.delete(o) <span class="comment">// true</span></div><div class="line">m.has(o) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([[<span class="string">"name"</span>, <span class="string">"张三"</span>], [<span class="string">"title"</span>, <span class="string">"Author"</span>]]);</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">size</span> <span class="comment">// 2</span></div><div class="line"><span class="built_in">map</span>.has(<span class="string">"name"</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"name"</span>) <span class="comment">// "张三"</span></div><div class="line"><span class="built_in">map</span>.has(<span class="string">"title"</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"title"</span>) <span class="comment">// "Author"</span></div></pre></td></tr></table></figure>
<ul>
<li>只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</div><div class="line">var arr1 = [<span class="string">'a'</span>];</div><div class="line">var arr2 = arr1;</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(arr1, <span class="number">111</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(arr1); <span class="comment">// 111</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(arr2, <span class="number">222</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(arr1); <span class="comment">// 222</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(arr2); <span class="comment">// 222</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>([<span class="string">'a'</span>]) <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<ul>
<li>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</li>
</ul>
<h3 id="属性及方法"><a href="#属性及方法" class="headerlink" title="属性及方法"></a>属性及方法</h3><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><ul>
<li>返回Map结构的成员总数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>, <span class="string">'A'</span>], [<span class="string">'b'</span>, <span class="string">'B'</span>]]);</div><div class="line"><span class="built_in">console</span>.log(a.size); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<h4 id="set-key-val"><a href="#set-key-val" class="headerlink" title="set(key, val)"></a>set(key, val)</h4><ul>
<li>方法返回的是Map本身，因此可以采用链式写法。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>()</div><div class="line">  .<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">'a'</span>)</div><div class="line">  .<span class="built_in">set</span>(<span class="number">2</span>, <span class="string">'b'</span>)</div><div class="line">  .<span class="built_in">set</span>(<span class="number">3</span>, <span class="string">'c'</span>);</div></pre></td></tr></table></figure>
<h4 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a>get(key)</h4><ul>
<li>读取key对应的键值，如果找不到key，返回undefined。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="literal">new</span> <span class="built_in">Map</span>().<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'A'</span>);</div><div class="line">console.<span class="keyword">log</span>(a.get(<span class="string">'a'</span>)); <span class="comment">// 'A'</span></div><div class="line">console.<span class="keyword">log</span>(a.get(<span class="string">'b'</span>)); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h4 id="has-key"><a href="#has-key" class="headerlink" title="has(key)"></a>has(key)</h4><ul>
<li>返回一个布尔值，表示某个键是否在Map数据结构中。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="literal">new</span> <span class="built_in">Map</span>().<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'A'</span>);</div><div class="line">console.<span class="keyword">log</span>(a.has(<span class="string">'a'</span>)); <span class="comment">// true</span></div><div class="line">console.<span class="keyword">log</span>(a.has(<span class="string">'b'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h4 id="delete-key"><a href="#delete-key" class="headerlink" title="delete(key)"></a>delete(key)</h4><ul>
<li>方法删除某个键，返回true。如果删除失败，返回false。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = <span class="keyword">new</span> Map().<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'A'</span>);</div><div class="line">console.<span class="built_in">log</span>(a.<span class="keyword">delete</span>(<span class="string">'a'</span>)); <span class="comment">// true</span></div><div class="line">console.<span class="built_in">log</span>(a.<span class="keyword">delete</span>(<span class="string">'b'</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><ul>
<li>清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="literal">new</span> <span class="built_in">Map</span>().<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'A'</span>);</div><div class="line">console.<span class="keyword">log</span>(a.clear()); <span class="comment">// undefined</span></div><div class="line">console.<span class="keyword">log</span>(a); <span class="comment">// Map &#123;&#125;</span></div></pre></td></tr></table></figure>
<h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><ul>
<li>返回键名的遍历器。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="string">'A'</span>).set(<span class="string">'b'</span>, <span class="string">'B'</span>);</div><div class="line"><span class="built_in">console</span>.log(a.keys()); <span class="comment">// MapIterator &#123;'a', 'b'&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> a.keys())&#123;</div><div class="line">  <span class="built_in">console</span>.log(k); <span class="comment">// 'a'、 'b'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><ul>
<li>返回键值的遍历器。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="string">'A'</span>).set(<span class="string">'b'</span>, <span class="string">'B'</span>);</div><div class="line"><span class="built_in">console</span>.log(a.values()); <span class="comment">// MapIterator &#123;'A', 'B'&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> a.values())&#123;</div><div class="line">  <span class="built_in">console</span>.log(k); <span class="comment">// 'A'、 'B'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><ul>
<li>返回所有成员的遍历器。</li>
</ul>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = new Map().set(<span class="string">'a'</span>, <span class="string">'A'</span>).set(<span class="string">'b'</span>, <span class="string">'B'</span>);</div><div class="line">console.log(a.entries()); // MapIterator &#123;[<span class="string">'a'</span>, <span class="string">'A'</span>], [<span class="string">'b'</span>, <span class="string">'B'</span>]&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> a.entries())&#123;</div><div class="line">  console.log(k); // [<span class="string">'a'</span>, <span class="string">'A'</span>]、 [<span class="string">'b'</span>, <span class="string">'B'</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><ul>
<li>遍历Map的所有成员。</li>
</ul>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = new Map().set(<span class="string">'a'</span>, <span class="string">'A'</span>).set(<span class="string">'b'</span>, <span class="string">'B'</span>);</div><div class="line">a.forEach(<span class="keyword">function</span>(<span class="keyword">value</span>, key, <span class="keyword">map</span>)&#123;</div><div class="line">  console.log(value, key, map); // <span class="string">'A'</span>, <span class="string">'a'</span>, Map &#123;<span class="string">'a'</span> =&gt; <span class="string">'A'</span>, <span class="string">'b'</span> =&gt; <span class="string">'B'</span>&#125;  <span class="string">'B'</span>, <span class="string">'b'</span>, Map &#123;<span class="string">'a'</span> =&gt; <span class="string">'A'</span>, <span class="string">'b'</span> =&gt; <span class="string">'B'</span>&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="Map结构转为数组结构"><a href="#Map结构转为数组结构" class="headerlink" title="Map结构转为数组结构"></a>Map结构转为数组结构</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let map = new <span class="symbol">Map</span>([</div><div class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</div><div class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</div><div class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</div><div class="line">]);</div><div class="line"></div><div class="line">[...map.keys()] // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">[...map.values()] // [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</div><div class="line">[...map.entries()] // [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</div><div class="line">[...map] // [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</div></pre></td></tr></table></figure>
<h4 id="结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。"><a href="#结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。" class="headerlink" title="结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。"></a>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let map0 = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line">  .<span class="keyword">set</span>(<span class="number">1</span>, <span class="string">'a'</span>)</div><div class="line">  .<span class="keyword">set</span>(<span class="number">2</span>, <span class="string">'b'</span>)</div><div class="line">  .<span class="keyword">set</span>(<span class="number">3</span>, <span class="string">'c'</span>);</div><div class="line"></div><div class="line">let map1 = <span class="keyword">new</span> <span class="built_in">Map</span>(</div><div class="line">  [...map0].filter(([k, v]) =&gt; k &lt; <span class="number">3</span>)</div><div class="line">); <span class="comment">// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></div><div class="line"></div><div class="line">let map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(</div><div class="line">  [...map0].map(([k, v]) =&gt; [k * <span class="number">2</span>, <span class="string">'^'</span> + v])</div><div class="line">); <span class="comment">// 产生Map结构 &#123;2 =&gt; '^a', 4 =&gt; '^b', 6 =&gt; '^c'&#125;</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Let & Const]]></title>
      <url>http://yoursite.com/let-const/</url>
      <content type="html"><![CDATA[<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li>它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">i</span>++)&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>用let命令声明，不会发生变量提升。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// error</span></div><div class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>暂时性死区。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></div><div class="line">  <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不允许重复声明。在相同作用域内重复用let声明同一个变量会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</div><div class="line">    <span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// error</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">var</span> tmp = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>声明一个只读的常量。一旦声明，常量的值就不能改变。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const <span class="literal">PI</span> = <span class="number">3.1415</span>;</div><div class="line"><span class="literal">PI</span> = <span class="number">3</span>; <span class="comment">// 常规模式时，重新赋值无效，但不报错</span></div><div class="line"><span class="literal">PI</span> <span class="comment">// 3.1415</span></div></pre></td></tr></table></figure>
<ul>
<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo; <span class="comment">// error</span></div></pre></td></tr></table></figure>
<ul>
<li>其它特性同let</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Iterator]]></title>
      <url>http://yoursite.com/Iterator/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Iterator并不是一组新的API，而是代表一种新的遍历数据的方式。<br>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）<br>在ES6中，有三类数据结构原生具备Iterator接口：<code>数组</code>、<code>部分类数组对象，如String</code>, <code>Set</code>和<code>Map</code>结构。</p>
</blockquote>
<a id="more"></a>
<h3 id="调用Iterator接口的场景"><a href="#调用Iterator接口的场景" class="headerlink" title="调用Iterator接口的场景"></a>调用Iterator接口的场景</h3><ul>
<li>解构赋值，对数组和Set结构进行解构赋值时</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let <span class="built_in">set</span> = <span class="keyword">new</span> Set().<span class="built_in">add</span>(<span class="string">'a'</span>).<span class="built_in">add</span>(<span class="string">'b'</span>).<span class="built_in">add</span>(<span class="string">'c'</span>);</div><div class="line">let [x, y] = <span class="built_in">set</span>; <span class="comment">// 解构赋值，调用Iterator</span></div></pre></td></tr></table></figure>
<ul>
<li>扩展运算符</li>
</ul>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">str</span> = <span class="string">'hello'</span>;</div><div class="line">[...<span class="keyword">str</span>];</div></pre></td></tr></table></figure>
<ul>
<li>yield*</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line">g.next();</div></pre></td></tr></table></figure>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Object.keys()等</li>
<li>Map(), Set()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h3 id="各种遍历数组的方法比较"><a href="#各种遍历数组的方法比较" class="headerlink" title="各种遍历数组的方法比较"></a>各种遍历数组的方法比较</h3><ul>
<li>for循环<ul>
<li>写法复杂</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, <span class="built_in">len</span>=arr.length; i &lt; <span class="built_in">len</span>; i++)&#123;</div><div class="line">    console.log(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>forEach<ul>
<li>无法通过break,return等方法终止遍历</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, i, arr</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(item)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>for…in<ul>
<li>遍历对象用，不适用于遍历对象</li>
<li>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</li>
<li>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>
<li>某些情况下，for…in循环会以任意顺序遍历键名。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123; <span class="comment">// 拿到的是index，不是内容元素</span></div><div class="line">    <span class="built_in">console</span>.log(arr[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>for…of<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</div><div class="line">    <span class="keyword">if</span>(item &gt; <span class="string">'a'</span>)&#123;</div><div class="line">        <span class="built_in">console</span>.log(item);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Generator]]></title>
      <url>http://yoursite.com/Generator/</url>
      <content type="html"><![CDATA[<blockquote>
<p>关键词：状态机，遍历器，同步方式写异步方法</p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>形式上，Generator函数是一个普通函数，但是有两个特征。<ul>
<li>function关键字与函数名之间有一个星号。</li>
<li>二是，函数体内部使用yield语句，定义不同的内部状态。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</div><div class="line"><span class="keyword">var</span> h = helloWorldGenerator();</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 接上面的demo</div><div class="line"></div><div class="line">hw.<span class="keyword">next</span>()</div><div class="line">// &#123; value: <span class="string">'hello'</span>, done: <span class="literal">false</span> &#125;</div><div class="line"></div><div class="line">hw.<span class="keyword">next</span>()</div><div class="line">// &#123; value: <span class="string">'world'</span>, done: <span class="literal">false</span> &#125;</div><div class="line"></div><div class="line">hw.<span class="keyword">next</span>()</div><div class="line">// &#123; value: <span class="string">'ending'</span>, done: <span class="literal">true</span> &#125;</div><div class="line"></div><div class="line">hw.<span class="keyword">next</span>()</div><div class="line">// &#123; value: undefined, done: <span class="literal">true</span> &#125;</div></pre></td></tr></table></figure>
<h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><ul>
<li>yield语句不能用在普通函数中，否则会报错</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">function</span> ()&#123;</div><div class="line">    yield <span class="number">1</span><span class="comment">;</span></div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<ul>
<li>yield语句如果用在一个表达式之中，必须放在圆括号里面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<ul>
<li>yield语句用作函数参数或赋值表达式的右边，可以不加括号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo(<span class="keyword">yield</span> <span class="string">'a'</span>, <span class="keyword">yield</span> <span class="string">'b'</span>); <span class="comment">// OK</span></div><div class="line"><span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></div></pre></td></tr></table></figure>
<h2 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h2><ul>
<li>如果主动调用return()方法，Generator函数将被终结</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line">g.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">g.<span class="keyword">return</span>(<span class="string">'foo'</span>) <span class="comment">// &#123;value: 'foo', done: true&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li><em>但是</em>，如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line">g.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">g.<span class="keyword">return</span>(<span class="number">10</span>) <span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line">g.next() <span class="comment">// &#123;value: 10, done: true&#125;</span></div></pre></td></tr></table></figure>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><ul>
<li>在一个Generater函数内部直接调用另外一个Generater函数无效</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> inner();</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o = outer();</div><div class="line">o.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">o.next(); <span class="comment">// &#123;value: inner, done: false&#125;</span></div><div class="line">o.next(); <span class="comment">// &#123;value: 3, done: true&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>上面的情况可以使用<code>yield*</code>解决</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span>* inner(); <span class="comment">// 调用方法与上面不同</span></div><div class="line">    <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o = outer();</div><div class="line">o.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">o.next(); <span class="comment">// &#123;value: 2, done: false&#125; // 返回结果与上面不同</span></div><div class="line">o.next(); <span class="comment">// &#123;value: 3, done: true&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>任何数据结构只要有Iterator接口，就可以被yield*遍历。</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function* demo()&#123;</div><div class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line">var d = demo();</div><div class="line">d.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</div><div class="line">d.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">2</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</div><div class="line">d.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> <span class="number">3</span>, <span class="symbol">done:</span> <span class="literal">false</span>&#125;</div><div class="line">d.<span class="keyword">next</span>(); <span class="regexp">//</span> &#123;<span class="symbol">value:</span> undefined, <span class="symbol">done:</span> <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> i = <span class="keyword">yield</span>* inner();</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span> + i;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o = outer();</div><div class="line">o.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">o.next(); <span class="comment">// &#123;value: 4, done: false&#125;</span></div></pre></td></tr></table></figure>
<h3 id="作为对象属性的Generator函数"><a href="#作为对象属性的Generator函数" class="headerlink" title="作为对象属性的Generator函数"></a>作为对象属性的Generator函数</h3><ul>
<li>如果一个对象的属性是Generator函数，可以简写成下面的形式。</li>
</ul>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    * gen()&#123;</div><div class="line">        yield <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var g = obj.gen();</div><div class="line">g.<span class="keyword">next</span>(); // &#123;value: <span class="number">1</span>, done: false&#125;</div></pre></td></tr></table></figure>
<h3 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h3><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>异步操作的同步化表达，逻辑更清晰</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">render</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    showLoading();</div><div class="line">    <span class="keyword">var</span> res = <span class="keyword">yield</span> getData();</div><div class="line">    hideLoading();</div><div class="line">    <span class="built_in">console</span>.log(res); <span class="comment">// 打印ajax的结果</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $.ajax().done(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">        r.next(res);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> r = render();</div><div class="line">r.next();</div></pre></td></tr></table></figure>
<ul>
<li>控制流管理，摆脱回调函数多层嵌套</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// callback方式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    step1(<span class="function"><span class="keyword">function</span>(<span class="params">res1</span>)</span>&#123;</div><div class="line">        step2(res1, <span class="function"><span class="keyword">function</span>(<span class="params">res2</span>)</span>&#123;</div><div class="line">            step3(res2, <span class="function"><span class="keyword">function</span>(<span class="params">res3</span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(res3);</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;)        </div><div class="line">&#125;</div><div class="line"><span class="comment">// promise方式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    step1()</div><div class="line">    .then(step2)</div><div class="line">    .then(step3)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">&#123;</span></span></div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125;))        </div><div class="line">&#125;</div><div class="line">// <span class="title">Generator</span>方式</div><div class="line"><span class="title">function</span> <span class="title">step</span>(<span class="params"></span>)&#123;</div><div class="line">    <span class="keyword">var</span> res1 = <span class="keyword">yield</span> step1();</div><div class="line">    <span class="keyword">var</span> res2 = <span class="keyword">yield</span> step2(res1);</div><div class="line">    <span class="keyword">var</span> res3 = <span class="keyword">yield</span> step3(res2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>多任务并行。如果yield语句后面的参数，是一个具有遍历器接口的对象，yield会遍历这个对象，再往下执行。这意味着，多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execTaskA</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">            resolve(<span class="string">'a'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execTaskB</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">            resolve(<span class="string">'b'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">execTasks</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> [resA, resB] = <span class="keyword">yield</span> [execTaskA(), execTaskB()];</div><div class="line">    <span class="comment">// let resB = yield* execTaskB();</span></div><div class="line">    <span class="built_in">console</span>.log(resA, resB);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> t = execTasks();</div><div class="line">t.next();</div></pre></td></tr></table></figure>
<ul>
<li>关于Generator函数的自动执行，可以关注github上的<code>co</code>组件</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Function]]></title>
      <url>http://yoursite.com/Function/</url>
      <content type="html"><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul>
<li>ES6中对于函数的扩展最吸引人的莫过于箭头函数啦，不多说，先学会再说。</li>
<li>函数体内的this对象，是定义时所在的对象，而不是使用时所在的对象，这个特性与正常函数不同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 箭头定义函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id); <span class="comment">// this指向&#123;id:42&#125;这个对象</span></div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</div><div class="line">foo.call(&#123; id: <span class="number">42</span> &#125;); <span class="comment">// 42</span></div><div class="line"></div><div class="line"><span class="comment">// 普通定义函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id); <span class="comment">// this指向window</span></div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</div><div class="line">foo.call(&#123; id: <span class="number">42</span> &#125;); <span class="comment">// 21</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。没有内部this。不过都ES6了，想要定义类，直接使用class不就得了</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var Demo = <span class="function"><span class="params">(foo)</span> =&gt;</span> <span class="built_in">console</span>.log(foo);</div><div class="line"><span class="keyword">new</span> Demo(<span class="string">'foo'</span>) <span class="regexp">//</span> 报错啦 testFunc <span class="keyword">is</span> <span class="keyword">not</span> a constructor</div></pre></td></tr></table></figure>
<ul>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数(…args)代替。</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">demo</span> = (foo) =&gt; console.<span class="built_in">log</span>(arguments);</div><div class="line"><span class="built_in">demo</span>() // 报错 arguments <span class="built_in">is</span> <span class="keyword">not</span> defined</div><div class="line"></div><div class="line">// 可以用Rest写法代替</div><div class="line"><span class="built_in">var</span> <span class="built_in">demo</span> = (...<span class="built_in">args</span>) =&gt; console.<span class="built_in">log</span>(<span class="built_in">args</span>);</div><div class="line"><span class="built_in">demo</span>('a') // [<span class="string">"a"</span>]</div></pre></td></tr></table></figure>
<ul>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。待研究^^!!</li>
</ul>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><ul>
<li>尾参数设置默认值</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">log</span> = (x, y = <span class="string">'World'</span>) =&gt; x + <span class="string">' '</span> + y;</div><div class="line"><span class="keyword">log</span>(<span class="string">'hello'</span>, <span class="string">'xiaoming'</span>); <span class="comment">// hello xiaoming</span></div><div class="line"><span class="keyword">log</span>(<span class="string">'hello'</span>); <span class="comment">// hello World</span></div></pre></td></tr></table></figure>
<h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><ul>
<li>返回未设置默认值的参数的个数</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">(x, y, z = <span class="number">1</span>)</span> =&gt;</span> <span class="number">1</span>).length <span class="regexp">//</span> <span class="number">2</span></div></pre></td></tr></table></figure>
<ul>
<li>如果设置默认值的参数不是尾参数，设置默认值的参数后面的未设置默认值的参数也不计入length</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">(x = <span class="number">1</span>, y, z)</span> =&gt;</span> <span class="number">1</span>).length <span class="regexp">//</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">y = x</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(y);</div><div class="line">&#125;</div><div class="line">foo() <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><ul>
<li>rest参数后面不能再有参数</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="selector-tag">a</span>, ...b) =&gt; <span class="number">1</span></div><div class="line">(<span class="selector-tag">a</span>, ..<span class="selector-class">.b</span>, c) =&gt; <span class="number">1</span> <span class="comment">// 报错</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fetch]]></title>
      <url>http://yoursite.com/fetch/</url>
      <content type="html"><![CDATA[<blockquote>
<p>事实标准，并不存在与ES6规范中，基于Promise实现。<br>目前项目中对Promise的<a href="http://caniuse.com/#search=promise" target="_blank" rel="external">兼容性</a>尚存在问题，如果在项目中应用fetch，需要引入<a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="external">es6-promise</a>和<a href="https://github.com/github/fetch" target="_blank" rel="external">fetch</a>。<br>以下提到为了浏览器兼容而引入的fech组件时统一使用’fech组件’代替。<br>该文档重点针对fetch组件进行详细说明。</p>
</blockquote>
<a id="more"></a>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>Request、Response、Header、Body：事实标准中暴露在window对象中，但在fetch组件中没有对外暴露接口，项目中不能使用，因此暂不做深入了解。在RN中可以直接使用</li>
<li>返回Promise对象</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>get</li>
</ul>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/test/content.json'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></div><div class="line">    <span class="keyword">return</span> data.json();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(data);</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>post</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">fetch</span>(<span class="string">'/test/content.json'</span>, &#123; <span class="comment">// url: fetch事实标准中可以通过Request相关api进行设置</span></div><div class="line">    <span class="attribute">method</span>: <span class="string">'POST'</span>,</div><div class="line">    <span class="attribute">mode</span>: <span class="string">'same-origin'</span>, <span class="comment">// same-origin|no-cors（默认）|cors</span></div><div class="line">    <span class="attribute">credentials</span>: <span class="string">'include'</span>, <span class="comment">// omit（默认，不带cookie）|same-origin(同源带cookie)|include(总是带cookie)</span></div><div class="line">    <span class="attribute">headers</span>: &#123; <span class="comment">// headers: fetch事实标准中可以通过Header相关api进行设置</span></div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> <span class="comment">// default: 'application/json'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attribute">body</span>: <span class="string">'a=1&amp;b=2'</span> <span class="comment">// body: fetch事实标准中可以通过Body相关api进行设置</span></div><div class="line">&#125;)<span class="selector-class">.then</span>(function(res)&#123; <span class="attribute">res</span>: fetch事实标准中可以通过Response相关api进行设置</div><div class="line">    return res.json();</div><div class="line">&#125;)<span class="selector-class">.then</span>(function(data)&#123;</div><div class="line">    console<span class="selector-class">.log</span>(data);</div><div class="line">&#125;)<span class="selector-class">.catch</span>(function(error)&#123;</div><div class="line">    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Response相关属性及方法"><a href="#Response相关属性及方法" class="headerlink" title="Response相关属性及方法"></a>Response相关属性及方法</h3><h4 id="bodyUsed"><a href="#bodyUsed" class="headerlink" title="bodyUsed"></a>bodyUsed</h4><ul>
<li>标记返回值是否被使用过</li>
<li>这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑</li>
</ul>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/test/content.json'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(res.bodyUsed); <span class="comment">// false</span></div><div class="line">    var data = res.json();</div><div class="line">    console.<span class="built_in">log</span>(res.bodyUsed); <span class="comment">//true</span></div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(data);</div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><ul>
<li>返回Headers对象，该对象实现了Iterator，可通过for…of遍历</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/test/content.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> headers = res.headers;</div><div class="line">    <span class="built_in">console</span>.log(headers.get(<span class="string">'Content-Type'</span>)); <span class="comment">// application/json</span></div><div class="line">    <span class="built_in">console</span>.log(headers.has(<span class="string">'Content-Type'</span>)); <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(headers.getAll(<span class="string">'Content-Type'</span>)); <span class="comment">// ["application/json"]</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> headers.keys())&#123;</div><div class="line">        <span class="built_in">console</span>.log(key); <span class="comment">// datelast-modified server accept-ranges etag content-length content-type</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> headers.values())&#123;</div><div class="line">        <span class="built_in">console</span>.log(value);</div><div class="line">    &#125;</div><div class="line">    headers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, arr</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(value); <span class="comment">// 对应values()的返回值</span></div><div class="line">        <span class="built_in">console</span>.log(key); <span class="comment">// 对应keys()的返回值</span></div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> res.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h4><ul>
<li>是否正常返回</li>
<li>代表状态码在<code>200-299</code>之间</li>
</ul>
<h4 id="status"><a href="#status" class="headerlink" title="status"></a>status</h4><ul>
<li>状态码<ul>
<li>200 成功</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h4><ul>
<li>状态描述<ul>
<li>‘OK’ 成功</li>
</ul>
</li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><code>basic</code>：正常的，同域的请求，包含所有的headers。排除<code>Set-Cookie</code>和<code>Set-Cookie2</code>。</li>
<li><code>cors</code>：Response从一个合法的跨域请求获得，一部分header和body可读。</li>
<li><code>error</code>：网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。</li>
<li><code>opaque</code>： Response从”no-cors”请求了跨域资源。依靠Server端来做限制。</li>
</ul>
<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><ul>
<li>返回完整的url字符串。如：’<a href="http://xxx.com/xx?a=1" target="_blank" rel="external">http://xxx.com/xx?a=1</a>‘</li>
</ul>
<h4 id="arrayBuffer"><a href="#arrayBuffer" class="headerlink" title="arrayBuffer()"></a>arrayBuffer()</h4><ul>
<li>返回ArrayBuffer类型的数据的Promise对象</li>
</ul>
<h4 id="blob"><a href="#blob" class="headerlink" title="blob()"></a>blob()</h4><ul>
<li>返回Blob类型的数据的Promise对象</li>
</ul>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><ul>
<li>生成一个Response的克隆</li>
<li>body只能被读取一次，但clone方法就可以得到body的一个备份</li>
<li>克隆体仍然具有bodyUsed属性，如果被使用过一次，依然会失效</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/test/content.json'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</div><div class="line">    var d = <span class="keyword">data</span>.clone();</div><div class="line">    d.text().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(text)</span></span>&#123;</div><div class="line">        console.<span class="built_in">log</span>(JSON.parse(text));</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">data</span>.json();</div><div class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</div><div class="line">    console.<span class="built_in">log</span>(<span class="keyword">data</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span><span class="params">(error)</span></span>&#123;</div><div class="line">    console.<span class="built_in">log</span>(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="json"><a href="#json" class="headerlink" title="json()"></a>json()</h4><ul>
<li>返回JSON类型的数据的Promise对象</li>
</ul>
<h4 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h4><ul>
<li>返回Text类型的数据的Promise对象</li>
</ul>
<h4 id="formData"><a href="#formData" class="headerlink" title="formData()"></a>formData()</h4><ul>
<li>返回FormData类型的数据的Promise对象</li>
</ul>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul>
<li>无法监控读取进度</li>
<li>无法中断请求</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Class]]></title>
      <url>http://yoursite.com/Class/</url>
      <content type="html"><![CDATA[<h3 id="第一次接触Class的你需要注意哪些地方"><a href="#第一次接触Class的你需要注意哪些地方" class="headerlink" title="第一次接触Class的你需要注意哪些地方"></a>第一次接触Class的你需要注意哪些地方</h3><ul>
<li>类结构体内部的方法定义不能（不需要）使用function字段</li>
<li>类名必须大写。好像没有明确规定，但你就当有这个规定吧</li>
<li>类结构体虽然是放在<code>{}</code>内，但此时的<code>{}</code>并不表示对象，而表示代码块，所以不要像之前定义prototype一样使用<code>,</code>分割各个函数</li>
<li>类结构体中的所有方法都会被挂载到prototype对象上，成为各实例的通用方法</li>
<li>同let&amp;const一样，不存在变量提升</li>
<li>不多说，都在demo里了，走一个。。。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">new Demo() <span class="comment">// 不存在变量提升，这里会报错</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; <span class="comment">// 类名大写</span></div><div class="line">  <span class="keyword">constructor</span>(x, y) &#123; <span class="comment">// 构造函数。可以不定义构造函数默认`constructor() &#123;&#125;`</span></div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  &#125; <span class="comment">// 不需要`,`分割</span></div><div class="line">  toString() &#123; <span class="comment">// 不需要`function`定义函数</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h3><ul>
<li>子类通过构造函数向父类传参</li>
<li>super代表父类的构造函数</li>
<li>调用super之后才能使用this关键字，否则会报错</li>
<li>demo</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoChild</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    constructor(...args)&#123;</div><div class="line">        <span class="keyword">this</span>.args = args; <span class="comment">// 报错啦，这里还没有this呢。。</span></div><div class="line">        <span class="keyword">super</span>(...args);</div><div class="line">        <span class="keyword">this</span>.args = args; <span class="comment">//这才对嘛。。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以继承原生构造函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123; <span class="comment">// 妈妈再也不用担心对原生构造函数的扩展带来的各种问题</span></div><div class="line">    constructor(...args)&#123;</div><div class="line">        <span class="keyword">super</span>(...args);</div><div class="line">    &#125;</div><div class="line">    toString()&#123;</div><div class="line">        console.log(<span class="symbol">'I</span> am better then <span class="type">Array</span>');</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">GoodArray</span>();</div><div class="line">arr.toString();</div></pre></td></tr></table></figure>
<h3 id="prototype-amp-proto"><a href="#prototype-amp-proto" class="headerlink" title="prototype &amp; __proto__"></a>prototype &amp; __proto__</h3><ul>
<li>__proto__总是指向父类</li>
<li>prototype的__proto__总是指向父类的prototype</li>
<li>绕死算了^v^</li>
</ul>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DemoChild.<span class="symbol">\_</span><span class="symbol">\_</span>proto<span class="symbol">\_</span><span class="symbol">\_</span> === Demo;</div><div class="line">DemoChild.prototype.<span class="symbol">\_</span><span class="symbol">\_</span>proto<span class="symbol">\_</span><span class="symbol">\_</span> === Demo.prototype;</div></pre></td></tr></table></figure>
<h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h3><ul>
<li>class内部可以定义get&amp;set方法，用于存取属性的值。用法和对象属性的getter&amp;setter相同</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(foo)&#123;</div><div class="line">        <span class="keyword">this</span>._foo = foo;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">get</span> foo()&#123;</div><div class="line">        console.log(<span class="string">'get foo: '</span> + <span class="keyword">this</span>._foo);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._foo;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> foo(<span class="keyword">val</span>)&#123;</div><div class="line">        <span class="keyword">this</span>._foo = <span class="keyword">val</span>;</div><div class="line">        console.log(<span class="string">'set foo: '</span> + <span class="keyword">this</span>._foo);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> demo = new Demo(<span class="number">111</span>);</div><div class="line">demo.foo = <span class="number">123</span>; <span class="comment">// set foo: 123</span></div><div class="line">demo.foo; <span class="comment">// get foo: 123</span></div></pre></td></tr></table></figure>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>static关键字</li>
<li>静态方法可以直接通过类名调用，不需要实例化</li>
<li>静态方法不会被实例继承</li>
<li>父类的静态方法可以被子类继承</li>
<li>静态方法也可以通过supper()调用</li>
<li>来个糖炒栗子吧</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</div><div class="line">    static hello()&#123;</div><div class="line">        console.log(<span class="symbol">'hell</span>o');</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildDemo</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> <span class="type">Demo</span>();</div><div class="line"><span class="keyword">var</span> childDemo = <span class="keyword">new</span> <span class="type">ChildDemo</span>();</div><div class="line"><span class="type">Demo</span>.hello(); <span class="comment">// hello</span></div><div class="line"><span class="type">ChildDemo</span>.hello(); <span class="comment">// hello</span></div><div class="line">demo.hello(); <span class="comment">// 报错啦</span></div><div class="line">childDemo.hello(); <span class="comment">// 根本就没执行到我，其实我也一样报错</span></div></pre></td></tr></table></figure>
<h3 id="静态属性和实例属性"><a href="#静态属性和实例属性" class="headerlink" title="静态属性和实例属性"></a>静态属性和实例属性</h3><ul>
<li>如何定义静态属性？ES6规定Class内部只允许定义静态方法，不允许定义静态属性，ES7中有内部定义静态属性的提案，但是那是ES7的事情了</li>
<li>实例属性只能在constructor中定义</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Demo&#123;</div><div class="line">    constructor(...<span class="built_in">props</span>)&#123;</div><div class="line">        this.<span class="built_in">props</span> = <span class="built_in">props</span>; // 定义实例属性</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Demo.<span class="built_in">props</span> = 'static <span class="built_in">props</span>';</div><div class="line"><span class="built_in">var</span> <span class="built_in">demo</span> = <span class="built_in">new</span> Demo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">console.<span class="built_in">log</span>(<span class="built_in">demo</span>.<span class="built_in">props</span>); // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">console.<span class="built_in">log</span>(Demo.<span class="built_in">props</span>); // 'static <span class="built_in">props</span>'</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Array]]></title>
      <url>http://yoursite.com/Array/</url>
      <content type="html"><![CDATA[<h3 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h3><ul>
<li>必须是arrayLike对象，没有length属性时，默认length为0</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrObj = &#123;</div><div class="line">    <span class="number">0</span>: <span class="string">'0'</span>,</div><div class="line">    <span class="number">1</span>: <span class="string">'1'</span>,</div><div class="line">    <span class="number">2</span>: <span class="string">'2'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arrObj); <span class="comment">// []</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>根据key生成响应的数组index。其它以undefined填充</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrObj = &#123;</div><div class="line">    <span class="number">1</span>: <span class="string">'0'</span>,</div><div class="line">    <span class="number">2</span>: <span class="string">'1'</span>,</div><div class="line">    <span class="number">3</span>: <span class="string">'2'</span>,</div><div class="line">    length: <span class="number">5</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arrObj); <span class="comment">// [undefined, '0', '1', '2', undefined]</span></div></pre></td></tr></table></figure>
<ul>
<li>传入第二个参数用于对每一个元素进行处理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrObj = &#123;</div><div class="line">    <span class="number">1</span>: <span class="string">'0'</span>,</div><div class="line">    <span class="number">2</span>: <span class="string">'1'</span>,</div><div class="line">    <span class="number">3</span>: <span class="string">'2'</span>,</div><div class="line">    length: <span class="number">5</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arrObj, (item) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> item || <span class="string">'hahah'</span>;</div><div class="line">&#125;); <span class="comment">// ['hahah', '0', '1', '2', 'hahah']</span></div></pre></td></tr></table></figure>
<ul>
<li>传入第三个参数，用于改变this指向</li>
</ul>
<h3 id="of"><a href="#of" class="headerlink" title="of()"></a>of()</h3><ul>
<li>将一组值转换成数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [3, 4, 5]</span></div></pre></td></tr></table></figure>
<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[].copyWithin.call(&#123;length: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></div><div class="line"><span class="keyword">var</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 对于没有部署TypedArray的copyWithin方法的平台</span></div><div class="line"><span class="comment">// 需要采用下面的写法</span></div><div class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><ul>
<li>找出第一个符合条件的数组成员</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>].find((item) =&gt; item &lt; <span class="number">2</span>) <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<ul>
<li>回调的三个参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>].find((item, index, arr) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> item &gt; <span class="number">1</span></div><div class="line">    <span class="built_in">console</span>.log(item);</div><div class="line">    <span class="built_in">console</span>.log(index);</div><div class="line">    <span class="built_in">console</span>.log(arr);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><ul>
<li>indexOf无法判断NAN</li>
<li>indexOf无法判断数组中的对象</li>
<li>如果没有匹配的值，返回-1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>].findIndex((item, index, arr) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> item &gt; <span class="number">1</span>;</div><div class="line">&#125;) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<h3 id="arr-fill-item-start-end"><a href="#arr-fill-item-start-end" class="headerlink" title="arr.fill(item, start, end)"></a>arr.fill(item, start, end)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</div><div class="line"><span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</div><div class="line"><span class="comment">// [7, 7, 7]</span></div><div class="line"></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="comment">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>
<h3 id="arr-entries"><a href="#arr-entries" class="headerlink" title="arr.entries()"></a>arr.entries()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure>
<h3 id="arr-keys"><a href="#arr-keys" class="headerlink" title="arr.keys()"></a>arr.keys()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="arr-values"><a href="#arr-values" class="headerlink" title="arr.values()"></a>arr.values()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div></pre></td></tr></table></figure>
<h3 id="空位处理"><a href="#空位处理" class="headerlink" title="空位处理"></a>空位处理</h3><ul>
<li>所有ES6方法都明确将数组中的空位转换成undefined</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</div><div class="line"><span class="comment">// [ "a", undefined, "b" ]</span></div><div class="line"></div><div class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</div><div class="line"><span class="comment">// [ "a", undefined, "b" ]</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[变量的解构赋值]]></title>
      <url>http://yoursite.com/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<blockquote>
<p>按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>
</blockquote>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><ul>
<li><p>如果解构不成功，变量的值就等于undefined。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [a, b, c, d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="comment">// var a = 1;</span></div><div class="line"><span class="comment">// var b = 2;</span></div><div class="line"><span class="comment">// var c = 3;</span></div><div class="line"><span class="comment">// var d = undefined;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line"><span class="comment">// var a = 1;</span></div><div class="line"><span class="comment">// var b = 2;</span></div><div class="line"><span class="comment">// var c = 3;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line"><span class="comment">// var third = "baz";</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="comment">// var head // 1</span></div><div class="line"><span class="comment">// var tail // [2, 3, 4]</span></div></pre></td></tr></table></figure>
</li>
<li><p>解构赋值允许指定默认值。内部使用严格相等运算符（===），判断一个位置是否有值。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [foo = <span class="literal">true</span>] = []; <span class="comment">// true</span></div><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>]; <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]; <span class="comment">// null</span></div></pre></td></tr></table></figure>
<ul>
<li>如果等号的右边不是数组（不是可遍历的结构），将会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</div><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div></pre></td></tr></table></figure>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; </div><div class="line">    foo, </div><div class="line">    bar </div><div class="line">&#125; = &#123; </div><div class="line">    foo: <span class="string">'aaa'</span>, </div><div class="line">    bar: <span class="string">'bbb'</span> </div><div class="line">&#125;;</div><div class="line"><span class="comment">// var foo = 'aaa';</span></div><div class="line"><span class="comment">// var bar = 'bbb';</span></div></pre></td></tr></table></figure>
<ul>
<li>如果变量名与属性名不一致，必须写成下面这样。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; </div><div class="line">    first: <span class="string">'hello'</span>, </div><div class="line">    last: <span class="string">'world'</span> </div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> &#123; </div><div class="line">    first: f, </div><div class="line">    last: l</div><div class="line">&#125; = obj;</div><div class="line"><span class="comment">// let f = 'hello';</span></div><div class="line"><span class="comment">// let l = 'world';</span></div></pre></td></tr></table></figure>
<ul>
<li>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x;</div><div class="line">&#123;x&#125; = &#123;x: <span class="number">1</span>&#125;; <span class="comment">// error，大括号被解析成代码块</span></div><div class="line">(&#123;x&#125; = &#123;x: <span class="number">1</span>&#125;); <span class="comment">// right</span></div></pre></td></tr></table></figure>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line"><span class="comment">// const a = 'h';</span></div><div class="line"><span class="comment">// const b = 'e';</span></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<ul>
<li>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;length : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h4><ul>
<li>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;toString: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure>
<ul>
<li>undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; prop: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; prop: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<ul>
<li>函数参数的解构也可以使用默认值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = 0, y = 0&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line">move(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h4 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<h4 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;</div><div class="line">    Component,</div><div class="line">    Dimensions,</div><div class="line">    Image,</div><div class="line">    View,</div><div class="line">    Platform,</div><div class="line">    StyleSheet,</div><div class="line">    Text,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<h4 id="解构赋值可以方便地将一组参数与变量名对应起来。"><a href="#解构赋值可以方便地将一组参数与变量名对应起来。" class="headerlink" title="解构赋值可以方便地将一组参数与变量名对应起来。"></a>解构赋值可以方便地将一组参数与变量名对应起来。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">f(&#123;z: <span class="number">3</span>, y: <span class="number">2</span>, x: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h4 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonData = &#123;</div><div class="line">  id: <span class="number">42</span>,</div><div class="line">  status: <span class="string">"OK"</span>,</div><div class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, data: number &#125; = jsonData;</div></pre></td></tr></table></figure>
<h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line">    async = true,</div><div class="line">    beforeSend = function () &#123;&#125;,</div><div class="line">    cache = <span class="literal">true</span>,</div><div class="line">    complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    crossDomain = <span class="literal">false</span>,</div><div class="line">    global = <span class="literal">true</span></div><div class="line">&#125;)&#123;&#125;;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模块]]></title>
      <url>http://yoursite.com/%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><blockquote>
<p>用于规定模块的对外接口</p>
</blockquote>
<ul>
<li>两种写法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 分别导出，必须在定义的时候</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="string">'a'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> b = <span class="string">'b'</span></div><div class="line"></div><div class="line"><span class="comment">// 整体导出，必须放在大括号内</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">'b'</span>;</div><div class="line"><span class="keyword">export</span> &#123;a, b&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>可以导出类或者函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>as</code>将输出的变量重命名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">export</span> &#123;</div><div class="line">    a <span class="keyword">as</span> a1, <span class="comment">// 外部使用时，获取到的是a1</span></div><div class="line">    b <span class="keyword">as</span> b1 <span class="comment">// 外部使用时，获取到的是b1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>必须在模块顶层调用，不能处于模块内的块级作用域中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// babel编译直接报错</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><blockquote>
<p>加载模块</p>
</blockquote>
<ul>
<li><p>几种写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 作为整体导入)</span></div><div class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">'./xxx'</span>; <span class="comment">// './xxx'中的所有export都会作为obj(任意定义)的属性</span></div><div class="line"></div><div class="line"><span class="comment">// *号导入</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">'./xxx'</span>; <span class="comment">// 同上一种写法相同</span></div><div class="line"></div><div class="line"><span class="comment">// 分别导入（解构赋值）</span></div><div class="line"><span class="keyword">import</span> &#123;a1, b1&#125; <span class="keyword">from</span> <span class="string">'./xxx'</span>; <span class="comment">// './xxx'中exporta1, b1</span></div><div class="line"></div><div class="line"><span class="comment">// 整体和部分导入</span></div><div class="line"><span class="keyword">import</span> obj, &#123;a1&#125; <span class="keyword">from</span> <span class="string">'./xxx'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>使用as关键字，将导入的变量重命名</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    a1 <span class="keyword">as</span> a2 <span class="comment">// './xxx'中导出a1，这里重命名为a2</span></div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'./xxx'</span>;</div></pre></td></tr></table></figure>
<ul>
<li>import会提升到模块头部执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">improt &#123;a1&#125; <span class="keyword">from</span> <span class="string">'./xxx'</span>; <span class="comment">// 这句会提前到顶部执行</span></div></pre></td></tr></table></figure>
<ul>
<li>可以不导入值，进做加载执行用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'./xxx'</span>;</div></pre></td></tr></table></figure>
<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><ul>
<li>使用default导出的变量，在使用import导入时，可以任意定义导入的变量名，不需要和导出时一致。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// b.js</span></div><div class="line"><span class="keyword">import</span> Haha <span class="keyword">from</span> <span class="string">'./a'</span>;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
